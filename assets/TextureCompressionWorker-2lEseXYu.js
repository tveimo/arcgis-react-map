import{_ as R,hw as b,ky as m}from"./index-rbwFz4i4.js";import{_ as D}from"./TextureFormat-1mYWTFa-.js";function X(){return T??(T=(async()=>{const t=await R(()=>import("./basis_encoder-UQPmgXGW.js"),[]),e=await t.default({locateFile:a=>b(`esri/libs/basisu/${a}`)});return e.initializeBasis(),e})()),T}let T;function B(){T=null}function x(){return y??(y=(async()=>await(await R(()=>import("./dxt_encoder-BWB8Wn-9.js"),[])).default({locateFile:e=>b(`esri/libs/dxtEncoder/${e}`)}))()),y}let y;function M(){y=null}let _,A,c=null,u=null;class w{constructor(e,a){this.internalFormat=e,this.compressedTexture=a}}function N(){c=null,_=null,u=null,A=null,B(),M()}async function Y(t){var a;let e;if(e=t.data instanceof ImageBitmap?O(t.data):v(t.data,t.width,t.height,t.components,t.needsFlip),t.hasS3TC){u||await S();const l=new Uint8Array(e.length);if(u!=null&&u.encode(e,t.width,t.height,t.preMultiplyAlpha,l)){const n=j(l,!0),i=[l.buffer];return{result:new w((n==null?void 0:n.internalFormat)??null,(n==null?void 0:n.textureData)??null),transferList:i}}return{result:new w(null,null)}}if(t.hasETC){if(c||await F(),t.preMultiplyAlpha&&!u&&await S(),t.preMultiplyAlpha){const r=new Uint8ClampedArray(e.length);u==null||u.premultiply(new Uint8Array(e),t.width,t.height,r),e=r}const l=await U(e,t.width,t.height,t.hasMipmap),n=l?await G(l):null,i=((a=n==null?void 0:n.compressedTexture)==null?void 0:a.levels.map(r=>r.buffer))||[];return{result:new w((n==null?void 0:n.internalFormat)??null,(n==null?void 0:n.compressedTexture)??null),transferList:i}}return{result:new w(null,null)}}async function F(){c||(c=await(_??(_=X())),_=null)}async function S(){u||(u=await(A??(A=x())),A=null)}async function U(t,e,a,l,n=255,i=0,r=!1,o=!1){if(!c)return null;const s=new c.BasisEncoder;s.setPerceptual(!o),s.setCheckForAlpha(!0),s.setForceAlpha(!1),s.setRenormalize(o),s.setMipGen(l),s.setMipSRGB(!o),s.setCreateKTX2File(!0),s.setKTX2SRGBTransferFunc(!o),s.setQualityLevel(n),s.setCompressionLevel(i);const f=new Uint8Array(t.byteLength);s.setSliceSourceImage(0,new Uint8Array(t),e,a,r);const d=s.encode(f),h=new Uint8Array(f.buffer,0,d),p=new c.KTX2File(new Uint8Array(h));return p.isValid()?(s.delete(),h):(p.close(),p.delete(),s.delete(),null)}async function G(t){if(!c)return new w(null,null);const e=new c.KTX2File(new Uint8Array(t));e.startTranscoding();const[a,l]=e.getHasAlpha()?[D.ETC2_RGBA,m.COMPRESSED_RGBA8_ETC2_EAC]:[D.ETC1_RGB,m.COMPRESSED_RGB8_ETC2],n=e.getLevels(),i=[];for(let r=0;r<n;r++)i.push(new Uint8Array(e.getImageTranscodedSizeInBytes(r,0,0,a))),e.transcodeImage(i[r],r,0,0,a,0,-1,-1);return e.close(),e.delete(),{internalFormat:l,compressedTexture:{type:"compressed",levels:i}}}function O(t){const e=new OffscreenCanvas(t.width,t.height),a=e.getContext("2d");return a.drawImage(t,0,0),a.getImageData(0,0,e.width,e.height).data}function v(t,e,a,l,n){const i=new Uint8ClampedArray(t).subarray(0,e*a*l);if(!n)return i;const r=new Uint8ClampedArray(i.length),o=e*l;for(let s=0;s<a;s++){const f=s*o,d=(a-s-1)*o;r.set(i.subarray(f,f+o),d)}return r}const I=31,P=1,L=2,k=3,K=4,z=7,$=21,V=131072;function C(t){return t.charCodeAt(0)+(t.charCodeAt(1)<<8)+(t.charCodeAt(2)<<16)+(t.charCodeAt(3)<<24)}const H=C("DXT1"),Q=C("DXT3"),W=C("DXT5");function j(t,e){const a=new Int32Array(t.buffer,t.byteOffset,I);let l,n;switch(a[$]){case H:l=8,n=m.COMPRESSED_RGB_S3TC_DXT1_EXT;break;case Q:l=16,n=m.COMPRESSED_RGBA_S3TC_DXT3_EXT;break;case W:l=16,n=m.COMPRESSED_RGBA_S3TC_DXT5_EXT;break;default:return null}let i=1,r=a[K],o=a[k];(3&r||3&o)&&(r=r+3&-4,o=o+3&-4);const s=r,f=o;let d,h;a[L]&V&&e!==!1&&(i=Math.max(1,a[z]));let p=t.byteOffset+a[P]+4;const E=[];for(let g=0;g<i;++g)h=(r+3>>2)*(o+3>>2)*l,d=new Uint8Array(t.buffer,p,h),E.push(d),p+=h,r=Math.max(1,r>>1),o=Math.max(1,o>>1);return{textureData:{type:"compressed",levels:E},internalFormat:n,width:s,height:f}}export{w as TextureCompressionWorkerOutput,Y as compress,U as compressRGBADataToKTX2,G as createTextureDataKTX2,N as destroy,F as initializeBasisEncoder,S as initializeDXTEncoder};
