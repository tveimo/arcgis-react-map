const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/densifyOperator-BXgvxwGY.js","assets/index-BU6th8yW.js","assets/index-IYDF6MEx.css","assets/Point2D-D2kgyQ2l.js","assets/ProjectionTransformation-CR5swo6Y.js","assets/Envelope2D-DpFkwyFI.js","assets/Transformation2D-DUMRLKSD.js","assets/OperatorDefinitions-DP7_WWTp.js","assets/jsonConverter-B8tWc3ge.js","assets/apiConverter-DRU8gNdC.js","assets/differenceOperator-BDBRz5W2.js","assets/lengthOperator-CM9nImNn.js"])))=>i.map(i=>d[i]);
import{aO as Pe,b$ as Y,m3 as ge,am as ie,cA as ne,av as $,ae as j,s as N,a6 as Re,gB as Fe,ao as Ie,bS as De,m4 as Be,ar as R,as as b,eU as be,at as oe,aL as $e,_ as Z,bY as Ce,eV as He,bJ as Je,b_ as ze,cB as Me}from"./index-BU6th8yW.js";import{r as V,g as we,N as Ne,i as Ee,a as Oe,p as Se,f as We,d as ce,w as Le,v as qe,h as Ae}from"./rasterFieldUtils-DWgFJiUL.js";import{u as Ge,N as ue,p as Ve,l as je,c as Ue,j as Qe,W as he,h as Xe,a as Ye,b as Ze,q as Ke,D as et,z as tt,B as me,t as it,i as fe}from"./RasterJobHandlerMixin-CyI2K-B9.js";import{j as nt,l as rt,a as st,x as at,_ as ot}from"./RasterSymbolizer-CUGvKudl.js";import{QueueProcessor as lt}from"./QueueProcessor-BzM1hyhR.js";import{i as ct,m as ut,h as ht,x as mt,s as ft}from"./RawBlockCache-CnyTOcLk.js";import{T as ee,N as ve,j as dt,u as pt,l as yt}from"./dataUtils-DJy9wk1Y.js";import{e as Q,v as re,A as de,u as pe,f as xt,o as te,Q as X,s as gt,i as Rt,_ as It,V as se}from"./rasterProjectionHelper-CHwr6msM.js";import{r as ae,p as bt}from"./clipUtils-Dykl9YJJ.js";import{T as wt}from"./rasterFunctionHelper-CMuiz65G.js";const ye=8,St=256;let vt=0,v=class extends Pe{constructor(){super(...arguments),this._tileFetchQueue=new lt({concurrency:32,process:(e,i)=>this._fetchRawTile(e.pyramidLevel,e.row,e.col,{...e.options,signal:i})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(e){return e!=null&&e.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:Y.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){const{rasterInfo:e}=this,i=Q(e.spatialReference);return i!=null&&e.extent.width>=i/2}get _hasNoneOrGCSShiftTransform(){const{transform:e}=this.rasterInfo;return e==null||e.type==="gcs-shift"}set rasterJobHandler(e){var i,r;this._set("rasterJobHandler",e),V(this)&&((r=(i=this.primaryRasters)==null?void 0:i.rasters)==null||r.forEach(s=>s.rasterJobHandler=e))}get rasterId(){return this.url||"rasterId-"+vt++}set url(e){this._set("url",ge(e,ie.getLogger(this)))}async open(e){return this._openPromise??(this._openPromise=re().then(()=>this._open(e))),this._openPromise}async fetchTile(e,i,r,s={}){const t=s.tileInfo||this.rasterInfo.storageInfo.tileInfo,n=this.getTileExtentFromTileInfo(e,i,r,t);return s={noClip:!0,...s},this.fetchPixels(n,t.size[0],t.size[1],s)}async identify(e,i={}){var C;e=ne($,e).clone().normalize();const{multidimensionalDefinition:r,timeExtent:s}=i,{rasterInfo:t}=this,{hasMultidimensionalTranspose:n,multidimensionalInfo:a}=t;let{transposedVariableName:o}=i;const c=a!=null&&n&&(s!=null||we(r));c&&!o&&(o=r!=null&&r.length>0?r[0].variableName??void 0:a.variables[0].name,i={...i,transposedVariableName:o}),i=this._getRequestOptionsWithSliceId(i);const{spatialReference:l,extent:u}=t,{datumTransformation:m}=i;let h=de(e,l,m);if(!u.intersects(h))return{location:h,value:null};if(t.transform!=null){const H=t.transform.inverseTransform(h);if(!t.nativeExtent.intersects(H))return{location:H,value:null};h=H}let p=0;const y=o!=null&&a!=null&&t.hasMultidimensionalTranspose;if(V(this)){const H=this.primaryRasters.rasters[0];if(y)return H.identify(h,i);const{pixelSize:z}=t,_=3,E=z.x*_/2,O=z.y*_/2,W=new j({xmin:h.x-E,xmax:h.x+E,ymin:h.y-O,ymax:h.y+O,spatialReference:l}),F={interpolation:"nearest",multidimensionalDefinition:r,sliceId:i.sliceId},{pixelBlock:T}=await H.fetchPixels(W,_,_,F),{pixelBlock:k}=await this.fetchPixels(W,_,_,F);if(T==null)return{location:h,value:null};const D=Math.floor(_*_*.5),L=!T.mask||T.mask[D]?T.pixels.map(B=>B[D]):null;let J;return k!=null&&(J=!k.mask||k.mask[D]?k.pixels.map(B=>B[D]):void 0),{location:h,value:L,processedValue:J,pyramidLevel:0}}if(!y){if(i.srcResolution)p=pe(i.srcResolution,t,this.ioConfig.sampling).pyramidLevel;else if(p=await this.computeBestPyramidLevelForLocation(e,i),p==null)return{location:h,value:null}}const g=this.identifyPixelLocation(h,p,null,y);if(g===null)return{location:h,value:null};const{row:d,col:f,rowOffset:x,colOffset:I,blockWidth:S}=g,w=await this._tileFetchQueue.push({pyramidLevel:p,row:d,col:f,options:i},{signal:i.signal});if(!((C=w==null?void 0:w.pixels)!=null&&C.length))return{location:h,value:null};const P=x*S+I;return this._processIdentifyResult(w,{srcLocation:h,position:P,pyramidLevel:p,useTransposedTile:!!y,requestSomeSlices:c,identifyOptions:i})}async fetchPixels(e,i,r,s={}){e=xt(e),s=this._getRequestOptionsWithSliceId(s);const{_hasNoneOrGCSShiftTransform:t}=this;if(s.requestRawData&&t)return this._fetchPixels(e,i,r,s);const n=Q(e.spatialReference),a=te(e);if(n==null||a===0||a===1&&this._isGlobalWrappableSource&&t)return this._fetchPixels(e,i,r,s);if(a>=3)return{extent:e,pixelBlock:null};const o=[],{xmin:c,xmax:l}=e,u=Math.round(n/(l-c)*i),m=u-Math.round((n/2-c)/(l-c)*i);let h=0;const p=[];for(let f=0;f<=a;f++){const x=new j({xmin:f===0?c:-n/2,xmax:f===a?l-n*f:n/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),I=f===0?u-m:f===a?i-h:u;h+=I,p.push(I);const S=s.disableWrapAround&&f>0?null:this._fetchPixels(x,I,r,s);o.push(S)}const y=(await Promise.all(o)).map(f=>f==null?void 0:f.pixelBlock);let g=null;const d={width:i,height:r};return this.rasterJobHandler?g=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:y,srcMosaicSize:d,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:p},s)).pixelBlock:g=ee(y,d,{blockWidths:p}),{extent:e,srcExtent:X(e,this.rasterInfo.spatialReference,s.datumTransformation),pixelBlock:g}}async fetchRawPixels(e,i,r,s={}){i={x:Math.floor(i.x),y:Math.floor(i.y)};const t=await this._fetchRawTiles(e,i,r,s),{nativeExtent:n,nativePixelSize:a,storageInfo:o}=this.rasterInfo,c=2**e,l=a.x*c,u=a.y*c,m=new j({xmin:n.xmin+l*i.x,xmax:n.xmin+l*(i.x+r.width-1),ymin:n.ymax-u*(i.y+r.height-1),ymax:n.ymax-u*i.y,spatialReference:n.spatialReference});if(!t)return{extent:m,srcExtent:m,pixelBlock:null};const{pixelBlocks:h,mosaicSize:p}=t;if(h.length===1&&h[0]!=null&&h[0].width===r.width&&h[0].height===r.height)return{extent:m,srcExtent:m,pixelBlock:t.pixelBlocks[0]};const y=e>0?o.pyramidBlockWidth:o.blockWidth,g=e>0?o.pyramidBlockHeight:o.blockHeight,d={x:i.x%y,y:i.y%g};let f;return this.rasterJobHandler?f=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:h,srcMosaicSize:p,destDimension:r,clipOffset:d,clipSize:r,coefs:null,sampleSpacing:null,interpolation:s.interpolation,alignmentInfo:null,blockWidths:null},s)).pixelBlock:f=ee(h,p,{clipOffset:d,clipSize:r}),{extent:m,srcExtent:m,pixelBlock:f}}fetchRawTile(e,i,r,s){throw new N("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return X(this.rasterInfo.extent,e)}decodePixelBlock(e,i){return!this.rasterJobHandler||i.useCanvas?nt(e,i):this.rasterJobHandler.decode({data:e,options:i})}async request(e,i,r=0){const{customFetchParameters:s}=this.ioConfig,{range:t,query:n,headers:a}=i;r=r??i.retryCount??this.ioConfig.retryCount;const o=t?{Range:`bytes=${t.from}-${t.to}`}:null;try{return await Re(e,{...i,query:{...n,...s},headers:{...a,...o}})}catch(c){if(r>0)return r--,this.request(e,i,r);throw c}}getSliceIndex(e){const{multidimensionalInfo:i}=this.rasterInfo;return i==null||e==null||e.length===0?null:Ne(e,i)}getTileExtentFromTileInfo(e,i,r,s){const t=s.lodAt(e);return this.getTileExtent({x:t.resolution,y:t.resolution},i,r,s.origin,s.spatialReference,s.size)}updateTileInfo(){const{storageInfo:e,spatialReference:i,extent:r,pixelSize:s}=this.rasterInfo,{pyramidResolutions:t}=e;if(!e.tileInfo){const n=[],a=e.maximumPyramidLevel||0;let o=(s.x+s.y)/2,c=1/.0254*96*o;for(let u=0;u<=a&&(n.unshift(new Fe({level:a-u,resolution:o,scale:c})),u!==a);u++)if(t){const m=(t[u].x+t[u].y)/2;c*=m/o,o=m}else o*=2,c*=2;const l=new $({x:r.xmin,y:r.ymax,spatialReference:i});e.tileInfo=new Y({origin:l,size:[e.blockWidth,e.blockHeight],spatialReference:i,lods:n}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,i=512,r=512,s){const{width:t,height:n,nativeExtent:a,pixelSize:o,spatialReference:c}=e,l=new $({x:a.xmin,y:a.ymax,spatialReference:c});s==null&&(s=Math.max(0,Math.round(Math.log(Math.max(t,n))/Math.LN2-8)));const u=this.computeBlockBoundary(a,512,512,{x:a.xmin,y:a.ymax},[o],s);e.storageInfo=new rt({blockWidth:i,blockHeight:r,pyramidBlockWidth:i,pyramidBlockHeight:r,origin:l,firstPyramidLevel:1,maximumPyramidLevel:s,blockBoundary:u})}async computeBestPyramidLevelForLocation(e,i={}){return 0}computeBlockBoundary(e,i,r,s,t,n=0,a=2){if(t.length===1&&n>0){t=[...t];let{x:u,y:m}=t[0];for(let h=0;h<n;h++)u*=a,m*=a,t.push({x:u,y:m})}const o=[],{x:c,y:l}=s;for(let u=0;u<t.length;u++){const{x:m,y:h}=t[u];o.push({minCol:Math.floor((e.xmin-c+.1*m)/i/m),maxCol:Math.floor((e.xmax-c-.1*m)/i/m),minRow:Math.floor((l-e.ymax+.1*h)/r/h),maxRow:Math.floor((l-e.ymin-.1*h)/r/h)})}return o}getPyramidPixelSize(e){const{nativePixelSize:i}=this.rasterInfo,{pyramidResolutions:r,pyramidScalingFactor:s}=this.rasterInfo.storageInfo;if(e===0)return i;if(r!=null&&r.length)return r[e-1];const t=s**e;return{x:i.x*t,y:i.y*t}}identifyPixelLocation(e,i,r,s){const{spatialReference:t,nativeExtent:n,storageInfo:a}=this.rasterInfo,{maximumPyramidLevel:o,origin:c,transposeInfo:l}=a,u=s&&l!=null?l.tileSize[0]:a.blockWidth,m=s&&l!=null?l.tileSize[1]:a.blockHeight,h=de(e,t,r);if(!n.intersects(h)||i<0||i>o)return null;const p=this.getPyramidPixelSize(i),{x:y,y:g}=p,d=(c.y-h.y)/g/m,f=(h.x-c.x)/y/u,x=Math.min(m-1,Math.floor((d-Math.floor(d))*m)),I=Math.min(u-1,Math.floor((f-Math.floor(f))*u));return{pyramidLevel:i,row:Math.floor(d),col:Math.floor(f),rowOffset:x,colOffset:I,blockWidth:u,srcLocation:h}}getTileExtent(e,i,r,s,t,n){const[a,o]=n,c=s.x+r*a*e.x,l=c+a*e.x,u=s.y-i*o*e.y,m=u-o*e.y;return new j({xmin:c,xmax:l,ymin:m,ymax:u,spatialReference:t})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,i,r){const s=this.rasterInfo.storageInfo.blockBoundary[e];return!s||s.maxRow<i||s.maxCol<r||s.minRow>i||s.minCol>r}updateImageSpaceRasterInfo(e){const{pixelSize:i}=e,{width:r,height:s}=e,t=Ie.WebMercator;e.spatialReference=t,e.extent=e.nativeExtent=new j({xmin:-.5,ymax:.5,xmax:r-.5,ymin:.5-s,spatialReference:t}),e.isPseudoSpatialReference=!0,e.transform=null,e.pixelSize=new $({x:1,y:1,spatialReference:t});const{extent:n,storageInfo:a}=e;if(a){a.origin=new $({x:n.xmin,y:n.ymax,spatialReference:t});const{pyramidResolutions:o,tileInfo:c}=a;if(o&&o.forEach(l=>{l.x/=i.x,l.y/=i.y}),c){c.origin=a.origin;const l=(e.nativePixelSize.x+e.nativePixelSize.y)/2;c.lods.forEach((u,m)=>{u.resolution=l*2**m,u.scale=96*u.resolution/.0254})}}}async _fetchPixels(e,i,r,s={}){let t=te(e);if(t>=2)return{extent:e,pixelBlock:null};const n=this._getSourceDataInfo(e,i,r,s),{pyramidLevel:a,srcResolution:o,srcExtent:c,srcWidth:l,srcHeight:u,ul:m}=n;if(l===0||u===0)return{extent:e,srcExtent:c,pixelBlock:null};const{rasterInfo:h}=this,p=h.transform,y=(p==null?void 0:p.type)==="gcs-shift",g=Q(e.spatialReference)!=null;!y&&g||(t=te(n.srcExtent,y));const d=await this._fetchRawTiles(a,m,{width:l,height:u,wrapCount:t},s);if(!d)return{extent:e,srcExtent:c,pixelBlock:null};const f=h.storageInfo,x=a>0?f.pyramidBlockWidth:f.blockWidth,I=a>0?f.pyramidBlockHeight:f.blockHeight;let{x:S,y:w}=h.pixelSize;if(a>0){const{pyramidResolutions:M,pyramidScalingFactor:ke}=f;if(M!=null&&M[a-1])({x:S,y:w}=M[a-1]);else{const le=ke**a;S*=le,w*=le}}const P=h.spatialReference,C=new $({x:S,y:w,spatialReference:P}),H=x===l&&I===u&&m.x%x===0&&m.y%I===0,z=new $({x:(e.xmax-e.xmin)/i,y:(e.ymax-e.ymin)/r,spatialReference:e.spatialReference}),_=!e.spatialReference.equals(P),E=P.isGeographic?1e-9:1e-4,{datumTransformation:O}=s;if(!_&&H&&d.pixelBlocks.length===1&&x===i&&I===r&&_t(o,z,E))return{extent:e,srcExtent:c,srcTilePixelSize:C,pixelBlock:d.pixelBlocks[0]};const W=g&&Q(c.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,F=s.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");F&&!this.rasterJobHandler&&await re();const T=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:d.extent,pixelSize:z.toJSON(),datumTransformation:O,rasterTransform:p,hasWrapAround:t>0||W,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:F},s):gt({projectedExtent:e,srcBufferExtent:d.extent,pixelSize:z,datumTransformation:O,rasterTransform:p,hasWrapAround:t>0||W,isAdaptive:!1,includeGCSGrid:F});let k;const D=!s.requestRawData,L={rows:T.spacing[0],cols:T.spacing[1]},J=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(a,d.extent.xmin):void 0,{pixelBlocks:B,mosaicSize:q,isPartiallyFilled:U}=d;let A=null;if(this.rasterJobHandler)({pixelBlock:k,localNorthDirections:A}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:B,srcMosaicSize:q,destDimension:D?{width:i,height:r}:null,coefs:D?T.coefficients:null,sampleSpacing:D?L:null,projectDirections:F,gcsGrid:F?T.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:s.interpolation,alignmentInfo:J,blockWidths:null},s));else{const M=ee(B,q,{alignmentInfo:J});k=D?ve(M,{width:i,height:r},T.coefficients,L,s.interpolation):M,F&&T.gcsGrid&&(A=dt({width:i,height:r},T.gcsGrid),k=pt(k,this.rasterInfo.dataType,A))}return s.requestRawData||F?{extent:e,srcExtent:c,srcTilePixelSize:C,pixelBlock:k,transformGrid:T,localNorthDirections:A,isPartiallyFilled:U}:{extent:e,srcExtent:c,srcTilePixelSize:C,pixelBlock:k}}async _fetchRawTiles(e,i,r,s){const{origin:t,blockBoundary:n}=this.rasterInfo.storageInfo,{blockWidth:a,blockHeight:o}=this.getBlockWidthHeight(e);let{x:c,y:l}=i,{width:u,height:m,wrapCount:h}=r;const p=this._getRasterTileAlignmentInfo(e,0);s.buffer&&(c-=s.buffer.cols,l-=s.buffer.rows,u+=2*s.buffer.cols,m+=2*s.buffer.rows);let y=0,g=0,d=0;h&&p!=null&&({worldColumnCountFromOrigin:g,originColumnOffset:d,rightPadding:y}=p,g*p.blockWidth-y>=c+u&&(y=0));const f=Math.floor(c/a),x=Math.floor(l/o),I=Math.floor((c+u+y-1)/a),S=Math.floor((l+m+y-1)/o),w=n[e];if(!w)return null;const{minRow:P,minCol:C,maxCol:H,maxRow:z}=w;if(h===0&&(S<P||I<C||x>z||f>H))return null;const _=new Array;let E=!1;const O=this.ioConfig.allowPartialFill==null?s.allowPartialFill:this.ioConfig.allowPartialFill;for(let J=x;J<=S;J++)for(let B=f;B<=I;B++){let q=B;if(!s.disableWrapAround&&h&&p!=null&&g<=B&&(q=B-g-d),J>=P&&q>=C&&z>=J&&H>=q){const U=this._tileFetchQueue.push({pyramidLevel:e,row:J,col:q,options:s},{signal:s.signal});O?_.push(new Promise(A=>{U.then(M=>A(M)).catch(()=>{E=!0,A(null)})})):_.push(U)}else _.push(Promise.resolve(null))}if(_.length===0)return null;const W=await Promise.all(_),F={height:(S-x+1)*o,width:(I-f+1)*a},{spatialReference:T}=this.rasterInfo,k=this.getPyramidPixelSize(e),{x:D,y:L}=k;return{extent:new j({xmin:t.x+f*a*D,xmax:t.x+(I+1)*a*D,ymin:t.y-(S+1)*o*L,ymax:t.y-x*o*L,spatialReference:T}),pixelBlocks:W,mosaicSize:F,isPartiallyFilled:E}}_fetchRawTile(e,i,r,s){const{storageInfo:t}=this.rasterInfo,n=t.transposeInfo!=null&&!!s.transposedVariableName;if(!n){const m=t.blockBoundary[e];if(!m)return Promise.resolve(null);const{minRow:h,minCol:p,maxCol:y,maxRow:g}=m;if(i<h||r<p||i>g||r>y)return Promise.resolve(null)}const a=n?s.transposeVariableName:s.sliceId,o=this.rasterInfo.storageInfo.isBsqTile?s.bandIds:null,c=ct(this.rasterId,a,o),l=`${e}/${i}/${r}`;let u=ut(c,s.registryId,l);if(u==null){const m=new AbortController;u=this.fetchRawTile(e,i,r,{...s,signal:m.signal}),ht(c,s.registryId,l,u,m),u.catch(()=>mt(c,s.registryId,l))}return s.signal&&De(s,()=>{ft(c,s.registryId,l)}),u}_computeMagDirValues(e){var c;const{bandCount:i,dataType:r}=this.rasterInfo;if(!(i===2&&r==="vector-magdir"||r==="vector-uv")||(e==null?void 0:e.length)!==2||!((c=e[0])!=null&&c.length))return null;const s=e[0].length;if(r==="vector-magdir"){const l=e[1].map(u=>(u+360)%360);return[e[0],l]}const[t,n]=e,a=[],o=[];for(let l=0;l<s;l++){const[u,m]=yt([t[l],n[l]]);a.push(u),o.push(m)}return[a,o]}_getRasterTileAlignmentInfo(e,i){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=Rt(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:i,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[e]}}_getSourceDataInfo(e,i,r,s={}){const t={datumTransformation:s.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};s.srcResolution&&(t.srcResolution=s.srcResolution,this._updateSourceDataInfo(e,t));const n=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:a,srcHeight:o,pyramidLevel:c}=t,l=a/i,u=o/r,m=c<n&&l*u>=16,h=c===n&&this._requireTooManySrcTiles(a,o,i,r);if(m||h||a===0||o===0){const p=new $({x:(e.xmax-e.xmin)/i,y:(e.ymax-e.ymin)/r,spatialReference:e.spatialReference});let y=It(p,this.rasterInfo.spatialReference,e,t.datumTransformation);const g=!y||s.srcResolution&&y.x+y.y<s.srcResolution.x+s.srcResolution.y;if(m&&s.srcResolution&&g){const d=Math.round(Math.log(Math.max(l,u))/Math.LN2)-1;if(n-c+3>=d){const f=2**d;y={x:s.srcResolution.x*f,y:s.srcResolution.y*f}}}y&&(t.srcResolution=y,this._updateSourceDataInfo(e,t))}return this._requireTooManySrcTiles(t.srcWidth,t.srcHeight,i,r)&&(t.srcWidth=0,t.srcHeight=0),t}_requireTooManySrcTiles(e,i,r,s){const{tileInfo:t}=this.rasterInfo.storageInfo,n=Math.ceil(e/t.size[0])*Math.ceil(i/t.size[1]),a=e/r,o=i/s,c=Math.max(1,(r+s)/1024);return n>=St*c||a>ye||o>ye}_updateSourceDataInfo(e,i){i.srcWidth=0,i.srcHeight=0;const{rasterInfo:r}=this,s=r.spatialReference,{srcResolution:t,datumTransformation:n}=i,{pyramidLevel:a,pyramidResolution:o,excessiveReading:c}=pe(t,r,this.ioConfig.sampling);if(c)return;let l=i.srcExtent||X(e,s,n);if(l==null)return;const u=r.transform;u&&(l=u.inverseTransform(l)),i.srcExtent=l;const{x:m,y:h}=r.storageInfo.origin,p=Math.floor((l.xmin-m)/o.x+.1),y=Math.floor((h-l.ymax)/o.y+.1),g=Math.floor((l.xmax-m)/o.x-.1),d=Math.floor((h-l.ymin)/o.y-.1),f=l.width<.1*o.x?0:g-p+1,x=l.height<.1*o.y?0:d-y+1;i.pyramidLevel=a,i.pyramidResolution=o,i.srcWidth=f,i.srcHeight=x,i.ul={x:p,y}}_getRequestOptionsWithSliceId(e){return this.rasterInfo.multidimensionalInfo!=null&&e.sliceId==null&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}_processIdentifyResult(e,i){const{srcLocation:r,position:s,pyramidLevel:t,useTransposedTile:n}=i,a=e.pixels[0].length/e.width/e.height;if(!(!e.mask||e.mask[s]))return{location:r,value:null};const{multidimensionalInfo:o}=this.rasterInfo;if(o==null||!n){const d=e.pixels.map(I=>I[s]),f={location:r,value:d,pyramidLevel:t},x=this._computeMagDirValues(d.map(I=>[I]));return x!=null&&x.length&&(f.magdirValue=x.map(I=>I[0])),f}let c=e.pixels.map(d=>d.slice(s*a,s*a+a)),l=this._computeMagDirValues(c);const{requestSomeSlices:u,identifyOptions:m}=i;let h=Ee(o,m.transposedVariableName);if(u){const d=Oe(h,m.multidimensionalDefinition,m.timeExtent);c=c.map(f=>d.map(x=>f[x])),l=l==null?void 0:l.map(f=>d.map(x=>f[x])),h=d.map(f=>h[f])}const p=e.noDataValues||this.rasterInfo.noDataValue,y={pixels:c,pixelType:e.pixelType};let g;return p!=null&&(Be(y,p),g=y.mask),{location:r,value:null,dataSeries:h.map((d,f)=>{const x={value:(g==null?void 0:g[f])===0?null:c.map(I=>I[f]),multidimensionalDefinition:d.multidimensionalDefinition.map(I=>new Se({...I,isSlice:!0}))};return l!=null&&l.length&&(x.magdirValue=[l[0][f],l[1][f]]),x}),pyramidLevel:t}}};function _t(e,i,r){return Math.abs(e.x-i.x)<r&&Math.abs(e.y-i.y)<r}R([b()],v.prototype,"_rasterTileAlignmentInfo",void 0),R([b()],v.prototype,"_tileFetchQueue",void 0),R([b({readOnly:!0})],v.prototype,"_isGlobalWrappableSource",null),R([b({readOnly:!0})],v.prototype,"_hasNoneOrGCSShiftTransform",null),R([b()],v.prototype,"_openPromise",void 0),R([b()],v.prototype,"rasterJobHandler",null),R([b({readOnly:!0})],v.prototype,"rasterId",null),R([b(be)],v.prototype,"url",null),R([b({type:String,json:{write:!0}})],v.prototype,"datasetName",void 0),R([b({type:String,json:{write:!0}})],v.prototype,"datasetFormat",void 0),R([b()],v.prototype,"hasUniqueSourceStorageInfo",void 0),R([b()],v.prototype,"rasterInfo",void 0),R([b()],v.prototype,"ioConfig",void 0),R([b()],v.prototype,"sourceJSON",void 0),v=R([oe("esri.layers.support.rasterDatasets.BaseRaster")],v);const Tt=40;let G=class extends v{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(e,i,r,s={}){var I,S;const{rasters:t,rasterIds:n}=this.primaryRasters;let a=!1;const{interpolation:o}=s,c=(I=this.rasterFunction.flatWebGLFunctionChain)==null?void 0:I.hasFocalFunction;!s.requestRawData&&c&&(a=t.length===1&&!s.skipRasterFunction,s={...s,interpolation:"bilinear",requestRawData:a}),s.requestRawData&&t.length>1&&!this.hasUniqueSourceStorageInfo&&(a=!1,s={...s,requestRawData:!1});const l=t.map(w=>w.fetchPixels(e,i,r,s)),u=await Promise.all(l),m=u.map(w=>w.pixelBlock),h=a||s.requestRawData?u.map(w=>w.srcTilePixelSize):null;if(s.skipRasterFunction||m.every(w=>w==null))return u[0];const p=((S=u.find(w=>w.pixelBlock!=null))==null?void 0:S.extent)??e;let y=this.rasterJobHandler?await this.rasterJobHandler.process({extent:p,primaryPixelBlocks:m,primaryPixelSizes:h,primaryRasterIds:n}):this.rasterFunction.process({extent:p,primaryPixelBlocks:m,primaryPixelSizes:h,primaryRasterIds:n});const{transformGrid:g}=u[0];if(!a||y==null||g==null){const w=s.noClip?null:this.getClippingGeometry(p.spatialReference);return s.noClip||s.requestRawData||y==null||!w||(y=await ae(y,p,w)),{...u[0],pixelBlock:y}}const d={rows:g.spacing[0],cols:g.spacing[1]};let f;this.rasterJobHandler?f=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[y],srcMosaicSize:{width:y.width,height:y.height},destDimension:{width:i,height:r},coefs:g.coefficients,sampleSpacing:d,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:o,alignmentInfo:void 0,blockWidths:null},s)).pixelBlock:f=ve(y,{width:i,height:r},g.coefficients,d,o);const x=s.noClip?null:this.getClippingGeometry(e.spatialReference);return s.noClip||s.requestRawData||f==null||x==null||(f=await ae(f,e,x)),{extent:e,srcExtent:u[0].srcExtent,pixelBlock:f}}getClippingGeometry(e){const i=this._clippingGeometry.get("0");if(!e||!i)return i;const r=Pt(e);let s=this._clippingGeometry.get(r);return s!=null||(s=e.equals(i.spatialReference)?i:se(i,e),this._clippingGeometry.set(r,s)),s}async _open(e){var l,u,m,h;const{rasterFunction:i}=this;i.isRoot=!0,(u=(l=this.primaryRasters)==null?void 0:l.rasters)!=null&&u.length?i.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=i.getPrimaryRasters(),this.rasterJobHandler&&((m=this.primaryRasters.rasters)==null||m.forEach(p=>p.rasterJobHandler=this.rasterJobHandler)));const{rasters:r,rasterIds:s}=this.primaryRasters,t=r.map(p=>p.rasterInfo?void 0:p.open(e));await Promise.all(t);const n=r.map(({rasterInfo:p})=>p),a=i.bind({rasterInfos:n,rasterIds:s});if(i.rawSourceRasterInfos=n,!a.success||n.length===0)throw new N("raster-function:open",`cannot bind the function: ${a.error??""}`);const o=i.functionName==="Table"?i:(h=i.functionArguments)==null?void 0:h.raster;(o==null?void 0:o.functionName)==="Table"&&(i.rasterInfo.attributeTable=$e.fromJSON(o.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const c=n[0];this.hasUniqueSourceStorageInfo=n.length===1||n.slice(1).every(p=>kt(p,c)),this.set("sourceJSON",r[0].sourceJSON),this.set("rasterInfo",i.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){var e;return(e=this.rasterJobHandler)==null?void 0:e.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const e=this.rasterFunction.getClippingGeometries()[0];let i=e==null?void 0:e.clippingGeometry;if(i&&e.clippingType==="inside"){const{extent:r}=this.rasterInfo,s=await Z(()=>import("./densifyOperator-BXgvxwGY.js").then(a=>a.d),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9])),t=await Z(()=>import("./differenceOperator-BDBRz5W2.js").then(a=>a.d),__vite__mapDeps([10,3,4,5,6,1,2,7,8,9]));let n=s.execute(Ce.fromExtent(r),2*(r.width+r.height)/Tt);n=se(n,i.spatialReference),i=t.execute(n,i)}this._clippingGeometry.clear(),i&&this._clippingGeometry.set("0",i)}};function kt(e,i){const{storageInfo:r,pixelSize:s,spatialReference:t,extent:n}=e,{storageInfo:a,pixelSize:o,spatialReference:c,extent:l}=i;return s.x===o.x&&s.y===o.y&&t.equals(c)&&n.equals(l)&&r.blockHeight===a.blockHeight&&r.blockWidth===a.blockWidth&&r.maximumPyramidLevel===a.maximumPyramidLevel&&r.firstPyramidLevel===a.firstPyramidLevel&&r.pyramidBlockWidth===a.pyramidBlockWidth&&r.pyramidBlockHeight===a.pyramidBlockHeight&&r.pyramidScalingFactor===a.pyramidScalingFactor}function Pt(e){return String(e.wkid??e.wkt??e.wkt2)}R([b({type:String,json:{write:!0}})],G.prototype,"datasetFormat",void 0),R([b()],G.prototype,"tileType",void 0),R([b()],G.prototype,"rasterFunction",void 0),R([b()],G.prototype,"primaryRasters",void 0),G=R([oe("esri.layers.support.rasterDatasets.FunctionRaster")],G);const xe=1e3,Ot=e=>{const i=e;let r=class extends i{constructor(...t){var n;super(...t),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=V((n=t[0])==null?void 0:n.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){var t;return(t=this.serviceRasterInfo)==null?void 0:t.extent}set multidimensionalDefinition(t){this._set("multidimensionalDefinition",t),this.updateRenderer()}set rasterFunction(t){var n;((n=t==null?void 0:t.functionName)==null?void 0:n.toLowerCase())==="none"&&(t=void 0),this._set("rasterFunction",t),this.updateRasterFunction()}set url(t){this._set("url",ge(t,ie.getLogger(this)))}get renderer(){if(this.type!=="imagery-tile")return this.internalRenderer;const{activePresetRendererName:t,presetRenderers:n}=this;if(t){const a=n==null?void 0:n.find(({name:o})=>o===t);return a==null?void 0:a.renderer.clone()}return this.internalRenderer}set renderer(t){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=t}set internalRenderer(t){t==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",t),this.updateRenderer())}readRenderer(t,n,a){var c,l;const o=(l=(c=n==null?void 0:n.layerDefinition)==null?void 0:c.drawingInfo)==null?void 0:l.renderer;return Ue(o,a)||void 0}async computeStatisticsHistograms(t,n){await this.load(n),t=ne(Qe,t).clone();const{serviceRasterInfo:a}=this;if(a==null)throw new N("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:o}=t;if(o==null)throw new N("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let c=o;const{spatialReference:l}=a;if(!o.spatialReference.equals(l)){await re();const f=o.type==="extent"?X(o,l):se(o,l);if(f==null)throw new N("imagery-tile-mixin:compute-statistics-histograms","geometry cannot be projected to the data source");c=f}const u=t.pixelSize??new $({x:a.pixelSize.x,y:a.pixelSize.y,spatialReference:l}),{extent:m,width:h,height:p}=bt(a,c,u),y=await this.fetchPixels(m,h,p,{...n,interpolation:"nearest"});if(y.pixelBlock==null)throw new N("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const g=await ae(y.pixelBlock,m,c),d=this._rasterJobHandler;return d?d.computeStatisticsHistograms({pixelBlock:g},n):at(g)}normalizeRasterFetchOptions(t){const{multidimensionalInfo:n}=this.serviceRasterInfo??{};if(n==null)return t;const a=We({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:t.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:t.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...t,multidimensionalDefinition:a,timeExtent:void 0}}async updateRasterFunction(){var t;return this.loaded&&this.type==="imagery-tile"&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=(t=this.rasterFunction)==null?void 0:t.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:t,symbolizer:n,renderer:a}=this;if(!t||!n||!a)return;const{rasterInfo:o}=this.raster,c=ce(o,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),l=c==null?void 0:c.name,u=he(o,l);return this._updateSymbolizer(n,a,l,u)}async applyRenderer(t,n,a){const o=t==null?void 0:t.pixelBlock;if(!(o!=null&&o.pixels&&o.pixels.length>0))return null;await this.updateRenderer();const c=this.bandIds??[],{pixelBlock:l}=await this._symbolize({pixelData:t,simpleStretchParams:n,bandIds:c,symbolizer:this.symbolizer},a);return l}getTileUrl(t,n,a){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${t}/${n}/${a}`:""}getCompatibleTileInfo(t,n,a=!1){if(!this.loaded||n==null)return null;if(a&&t.equals(this.spatialReference))return this.tileInfo;const o=Me(t);return Y.create({size:256,spatialReference:t,origin:o?{x:o.origin[0],y:o.origin[1]}:{x:n.xmin,y:n.ymax}})}getCompatibleFullExtent(t){var n;return this.loaded?((n=this._compatibleFullExtent)!=null&&n.spatialReference.equals(t)||(this._compatibleFullExtent=this.raster.computeExtent(t)),this._compatibleFullExtent):null}async fetchTile(t,n,a,o={}){var l;if(s(this),o.requestAsImageElement){const u=this.getTileUrl(t,n,a);return Re(u,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:o.signal}).then(m=>m.data)}const{serviceRasterInfo:c}=this;if(c.multidimensionalInfo!=null&&(o=this.normalizeRasterFetchOptions(o)).multidimensionalDefinition==null){const u=o.tileInfo||c.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(t,n,a,u),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),((l=this.renderer)==null?void 0:l.type)==="raster-shaded-relief"&&(o={...o,buffer:{cols:1,rows:1}}),this.raster.fetchTile(t,n,a,o)}async fetchPixels(t,n,a,o={}){return this.serviceRasterInfo.multidimensionalInfo!=null&&(o=this.normalizeRasterFetchOptions(o)).multidimensionalDefinition==null?{extent:t,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),n=Math.round(n),a=Math.round(a),this.raster.fetchPixels(t,n,a,o))}async getSamples(t,n){var u;if(await this.load(),(t=ne(Xe,t).clone()).interpolation&&t.interpolation!=="nearest")throw new N("imagery-tile-mixin:get-samples","only nearest interpolation is currently supported");const a=(u=t.mosaicRule)==null?void 0:u.multidimensionalDefinition,o={...n,multidimensionalDefinition:a},c=(await this._getSampleLocations(t)).map(m=>this.identify(m,o).then(h=>(h.location=m,h))),l=(await Promise.all(c)).flatMap((m,h)=>this._convertRasterIdentifyResultToSample(m,h));return new Ye({samples:l})}async identify(t,n={}){var u,m,h;await this.load();const{raster:a,serviceRasterInfo:o}=this;if((o==null?void 0:o.multidimensionalInfo)!=null&&!(o.hasMultidimensionalTranspose&&!(!we(n.multidimensionalDefinition)&&!n.transposedVariableName))&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null)return{location:t,value:null};const c=(u=this.multidimensionalSubset)==null?void 0:u.areaOfInterest;if(c&&!c.contains(t))throw new N("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");const l=(m=this.serviceRasterInfo)!=null&&m.storageInfo.isBsqTile&&((h=this.bandIds)!=null&&h.length)?this.bandIds:void 0;return a.identify(t,{...n,bandIds:l})}hasStandardTime(){var o,c,l;const t=(o=this.serviceRasterInfo)==null?void 0:o.multidimensionalInfo;if(t==null||((c=this.serviceRasterInfo)==null?void 0:c.dataType)!=="standard-time")return!1;const n=this.multidimensionalDefinition,a=(l=n==null?void 0:n[0])==null?void 0:l.variableName;return t.variables.some(u=>u.name===a&&(!(n!=null&&n[0].dimensionName)||u.dimensions.some(m=>m.name==="StdTime")))}getStandardTimeValue(t){return new Date(Le(t)).toISOString()}getMultidimensionalSubsetVariables(t){var a;const n=t??((a=this.serviceRasterInfo)==null?void 0:a.multidimensionalInfo);return qe(this.multidimensionalSubset,n)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=Ae(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&V(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then(async()=>{if(!this._rasterJobHandler)return;s(this);const{raster:t}=this;t.rasterJobHandler=this._rasterJobHandler,V(t)&&t.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{})}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(t){const{geometry:n}=t;if(n.type==="point")return[n];const{spatialReference:a,type:o}=n;if(o==="multipoint")return n.points.map(f=>new $({x:f[0],y:f[1],spatialReference:a}));if(o==="polyline"){let f=n;if(t.sampleCount||t.sampleDistance){const x=await Z(()=>import("./densifyOperator-BXgvxwGY.js").then(P=>P.d),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9])),I=(await Z(async()=>{const{execute:P}=await import("./lengthOperator-CM9nImNn.js").then(C=>C.l);return{execute:P}},__vite__mapDeps([11,1,2,3,5,4,6,7,8,9]))).execute(n,{unit:"meters"}),S=Math.min(t.sampleCount||100,xe);let w=t.sampleDistance;w||(w=I/(S+(f.paths[0].length===2?1:0))),f=x.execute(n,w,{unit:"meters"})}return f.paths.flatMap(x=>x.map(I=>new $({x:I[0],y:I[1],spatialReference:a})))}const c=Math.min(t.sampleCount||100,xe),l=n.type==="extent",u=l?n:n.extent,m=Math.sqrt(u.width*u.height/c),h=u.height/m,p=u.width/m,{xmin:y,ymax:g}=u,d=[];for(let f=0;f<h;f++)for(let x=0;x<p;x++){const I=new $({x:y+(x+.5)*m,y:g-(f+.5)*m,spatialReference:a});(l||n.contains(I))&&d.push(I)}return d}_configDefaultInterpolation(){var t;if(this.interpolation==null){s(this);const{raster:n}=this,a=Ze(n.rasterInfo,n.tileType,(t=this.sourceJSON)==null?void 0:t.defaultResamplingMethod);this._set("interpolation",a)}}_configDefaultRenderer(t="no"){var h,p,y;s(this);const{rasterInfo:n}=this.raster,a=ce(n,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),o=a==null?void 0:a.name,c=Ke({variableName:o,rasterFunctionName:(h=this.rasterFunction)==null?void 0:h.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&n.bandCount>1&&(this.bandIds=(c==null?void 0:c.bandIds)??et(n)),!this.renderer||t==="override"){const g=tt(this.raster),d=(c==null?void 0:c.renderer)??me(n,{bandIds:this.bandIds,variableName:o,rasterFunctionColorRamp:g}),f=n.statistics,x=f&&f.length>0?f[0]:null,I=(x==null?void 0:x.max)??0,S=(x==null?void 0:x.min)??0;this.raster.datasetFormat==="WCSServer"&&d.type==="raster-stretch"&&(I>1e24||S<-1e24)&&(d.dynamicRangeAdjustment=!0,d.customStatistics=null,d.stretchType==="none"&&(d.stretchType="min-max")),this.renderer=d}const l=it({...this.renderer.toJSON(),variableName:o}),u=he(n,o);this.symbolizer?(this.symbolizer.rendererJSON=l,this.symbolizer.rasterInfo=u):this.symbolizer=new ot({rendererJSON:l,rasterInfo:u});const m=this.symbolizer.bind();if(m.success){if(t==="auto"){const{colormap:g}=this.raster.rasterInfo,d=this.renderer;if(g!=null&&d.type==="raster-colormap"){const f=me(this.raster.rasterInfo);JSON.stringify(f)!==JSON.stringify(d)&&this._configDefaultRenderer("override")}else if(d.type==="raster-stretch"){const f=(p=this.bandIds)==null?void 0:p.length,x=(y=d.customStatistics)==null?void 0:y.length;!d.dynamicRangeAdjustment&&x&&f&&x!==f&&this._configDefaultRenderer("override")}}}else ie.getLogger(this).warn("imagery-tile-mixin",m.error||"The given renderer is not supported by the layer."),t==="auto"&&this._configDefaultRenderer("override")}async _updateRasterFunction(){var m;if(this._isConstructedFromFunctionRaster&&V(this.raster)){const h=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&h&&this._set("rasterFunction",ue.fromJSON(h)))}let t,n=this.raster,a=!1;V(n)?(t=n.primaryRasters.rasters,n=t[0],a=!0):t=[n];const{rasterFunction:o}=this;if(o){const h={raster:n};t.length>1&&t.forEach(g=>h[g.url]=g);const p=wt(((m=o.functionDefinition)==null?void 0:m.toJSON())??o.toJSON(),h),y=new G({rasterFunction:p});y.rasterJobHandler=this._rasterJobHandler,await y.open(),this.raster=y}else this.raster=n,await n.open();if(this._cachedRendererJson=void 0,!a&&!o)return;const{bandIds:c}=this,{bandCount:l}=this.raster.rasterInfo,u=c!=null&&c.length?c.some(h=>h>=l):l>=3;c&&(u||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}_convertRasterIdentifyResultToSample(t,n){var u;const{rasterInfo:a}=this.raster,o=a.storageInfo.pyramidScalingFactor**(t.pyramidLevel??0),c=(a.pixelSize.x+a.pixelSize.y)/2*o;if(!((u=t.dataSeries)!=null&&u.length))return[new fe({location:t.location,pixelValue:t.value,locationId:n,resolution:c})];const l=[];return t.dataSeries.forEach(({value:m,multidimensionalDefinition:h},p)=>{const y={Variables:h[0].variableName,Dimensions:h.flatMap(({dimensionName:d})=>d).join(",")};for(const{dimensionName:d,values:f}of h){y[d]=Array.isArray(f[0])?f[0][0]:f[0];const x=f[f.length-1];y[`${d}_Max`]=Array.isArray(x)?x[x.length-1]:x}const g=new fe({location:t.location,pixelValue:m,rasterId:p,locationId:n,resolution:c,attributes:y});l.push(g)}),l}};function s(t){if(!t.raster||!t.serviceRasterInfo)throw new N("imagery-tile","no raster")}return R([b({clonable:!1})],r.prototype,"_cachedRasterFunctionJson",void 0),R([b({clonable:!1})],r.prototype,"_compatibleFullExtent",void 0),R([b({clonable:!1})],r.prototype,"_isConstructedFromFunctionRaster",void 0),R([b({clonable:!1})],r.prototype,"_rasterFunctionUpdatePromise",void 0),R([b({type:[He],json:{write:{overridePolicy(){var t;return{enabled:!this.loaded||this.raster.tileType==="Raster"||((t=this.bandIds)==null?void 0:t.join(","))!=="0,1,2"}}}}})],r.prototype,"bandIds",void 0),R([b({json:{origins:{service:{read:{source:"copyrightText"}}}}})],r.prototype,"copyright",void 0),R([b({json:{read:!1}})],r.prototype,"fullExtent",null),R([b({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),Je(st)],r.prototype,"interpolation",void 0),R([b()],r.prototype,"ioConfig",void 0),R([b({type:[Se],json:{write:!0}})],r.prototype,"multidimensionalDefinition",null),R([b({type:Ge,json:{write:!0}})],r.prototype,"multidimensionalSubset",void 0),R([b()],r.prototype,"raster",void 0),R([b({type:ue})],r.prototype,"rasterFunction",null),R([b()],r.prototype,"serviceRasterInfo",void 0),R([b()],r.prototype,"sourceJSON",void 0),R([b({readOnly:!0,type:Ie,json:{read:!1}})],r.prototype,"spatialReference",void 0),R([b({type:Y})],r.prototype,"tileInfo",void 0),R([b(be)],r.prototype,"url",null),R([b()],r.prototype,"renderer",null),R([b({types:je,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){var n;const t=((n=this.renderer)==null?void 0:n.type)==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!t}}},origins:{"web-scene":{types:Ve,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:t=>({enabled:t&&t.type!=="vector-field"&&t.type!=="flow"})}}}}})],r.prototype,"internalRenderer",null),R([ze("internalRenderer")],r.prototype,"readRenderer",null),R([b({clonable:!1})],r.prototype,"symbolizer",void 0),r=R([oe("esri.layers.mixins.ImageryTileMixin")],r),r};function K(e,i){if(!e||!i)return[];let r=i;i.includes("/")?(r=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const s=[];if(i){const n=K(e,r);for(let a=0;a<n.length;a++)K(n[a],i).forEach(o=>s.push(o));return s}const t=e.getElementsByTagNameNS("*",r);if(!t||t.length===0)return[];for(let n=0;n<t.length;n++)s.push(t[n]||t.item(n));return s}function _e(e,i){if(!e||!i)return null;let r=i;i.includes("/")?(r=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const s=K(e,r);return s.length>0?i?_e(s[0],i):s[0]:null}function Te(e,i=null){const r=i?_e(e,i):e;let s;return r?(s=r.textContent||r.nodeValue,s?s.trim():null):null}function Ft(e,i){const r=K(e,i),s=[];let t;for(let n=0;n<r.length;n++)t=r[n].textContent||r[n].nodeValue,t&&(t=t.trim(),t!==""&&s.push(t));return s}function Wt(e,i=null){const r=Te(e,i);return(r==null?void 0:r.split(" ").map(s=>Number(s)))??[]}function Lt(e,i){return Ft(e,i).map(r=>Number(r))}function qt(e,i){const r=Te(e,i);return Number(r)}function At(e,i){var t;const r=(t=e==null?void 0:e.nodeName)==null?void 0:t.toLowerCase(),s=i.toLowerCase();return r.slice(r.lastIndexOf(":")+1)===s}function Gt(e){return e.nodeName.slice(e.nodeName.lastIndexOf(":")+1)}export{v as $,Ot as X,Gt as c,_e as e,At as i,Ft as l,G as m,K as n,qt as o,Wt as r,Te as t,Lt as u};
