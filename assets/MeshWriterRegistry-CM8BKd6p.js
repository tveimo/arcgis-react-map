import{e as P}from"./TechniqueType-CFPo0AVB.js";import{el as M,nn as F,no as te,np as W,cp as D,h7 as be,h6 as Ie,nq as S,bx as O,nr as G,ns as V,nt as $e,nu as j,nv as A,jD as E,nw as se,nx as re,ny as ie,nz as ae,kj as me,jW as w,h2 as z,nA as ne,nB as Z,nC as ze,nD as oe,L as k,nE as Le,aH as Ae,am as De,s as Se}from"./index-Btyj_e22.js";import{o as fe,N as Ee,x as X,d as Y,O as ke,f as N,F as Q,y as H,m as J,l as pe,s as Re,a as K,b as Te,t as Be,p as _e,u as Ce,T as Fe,k as We,S as ye,c as Oe,g as Ge,h as Ve,i as je,r as Ze,j as qe,A as ge,n as Xe,P as B,q as Ye,v as Ne,w as Qe,z as He,B as Je,C as Ke,D as Ue,E as et,G as tt,H as st,I as rt,J as it,K as at,L as nt,M as ot,Q as ct,R as lt,U as ht,V as ut,W as dt,X as mt,Y as ft,Z as pt}from"./PieChartMeshWriter-t33tMoG8.js";import{c as _t}from"./constants-BFLErLYb.js";import{c as yt}from"./libtess-DuUa0LEu.js";import{d as gt,l as ce}from"./featureConversionUtils-3V6t1IaM.js";import{n as le,r as xt}from"./Utils-C9fv26Zt.js";import{s as Pt}from"./AttributeStore-DtyyHX_9.js";function U(p){let{pixelDimensions:e,texelDimensions:t,baseSize:n,referenceSize:r,strokeWidth:s,sizeRatio:i}=p;if(e||(e=p.sprite.sdf?[0,0]:[p.sprite.width,p.sprite.height]),t||(t=p.sprite.sdf?[0,0]:e),p.patternHeight!=null){const o=p.patternHeight/e[1];e[1]*=o,e[0]*=o}n===-1&&(n=e[1]),n=M(n),r=M(r),s=M(s);const a=(p.sprite.sdfDecodeCoeff??1)*i;return{...p,pixelDimensions:e,texelDimensions:t,baseSize:n,referenceSize:r,strokeWidth:s,sdfDecodeCoeff:a}}const q=64,vt=64,Mt=2;let xe=class extends fe{get vertexSpec(){return{createComputedParams:U,optionalAttributes:{zoomRange:K,value1Position2Value2:Re,lineLength:pe},attributes:{id:J,bitset:H,pos:Q,offset:N.marker,uv:ke.marker,animationPointerAndBaseSizeAndReferenceSize:Y,sizing:X,angle:Ee}}}_write(e,t){const n=this.evaluatedMeshParams.sprite,{textureBinding:r}=n;e.recordStart(this.instanceId,this.attributeLayout,r);const s=t.getDisplayId();if(this.shift&&t.geometryType==="esriGeometryPolyline")this._writeParticles(e,t);else if(this.evaluatedMeshParams.placement!=null)this._writePlacedMarkers(e,t);else if(t.geometryType==="esriGeometryPolygon"){const i=t.readCentroidForDisplay();if(!i)return;const[a,o]=i.coords;this._writeQuad(e,s,a,o)}else if(t.geometryType==="esriGeometryPoint"){const i=t.readXForDisplay(),a=t.readYForDisplay();this._writeQuad(e,s,i,a)}else{const i=t.readGeometryForDisplay();i&&i.forEachVertex((a,o)=>{this._writeQuad(e,s,a,o)})}e.recordEnd()}_writePlacedMarkers(e,t){var l;const n=(l=F.fromFeatureSetReaderCIM(t))==null?void 0:l.clone();if(!n)return;const r=-1,s=Te.getPlacement(n,r,this.evaluatedMeshParams.placement,M(1),e.id,Be());if(!s)return;const i=t.getDisplayId();let a=s.next(),o=null;for(;a!=null;){const c=a.tx,m=-a.ty;if(Math.abs(c)>te||Math.abs(m)>te){a=s.next();continue}const h=-a.getAngle();e.recordBounds(c,m,q,vt),this.shift?o&&this._writeQuad(e,i,o[0],o[1],void 0,h):this._writeQuad(e,i,c,m,void 0,h),o=[c,m],a=s.next()}}_writeParticles(e,t){const n=t.getDisplayId(),r=t.readGeometryForDisplay();if(!r)return;const s=[];r.forEachVertex((c,m)=>{s.push([c,m])});const i=wt(s);let a=0;for(let c=1;c<s.length;c++){const m=s[c][0]-s[c-1][0],h=s[c][1]-s[c-1][1],u=Math.sqrt(m*m+h*h);a+=u}const o=c=>{for(const m of i){const{a:h,b:u}=m;this._writeQuad(e,n,h.position[0],h.position[1],[h.distance-c,u.position[0],u.position[1],u.distance-c],this.evaluatedMeshParams.angleToLine?Math.atan2(h.direction[1],h.direction[0]):0,a,!0)}},{placement:l}=this.evaluatedMeshParams;if(!l||"placementTemplate"in l||l.type==="CIMMarkerPlacementOnVertices"){let c;if(l&&l.type!=="CIMMarkerPlacementOnVertices")c=l.placementTemplate;else{c=[0];for(const h of i){const{a:u,b:f}=h,d=u.position[0]-f.position[0],_=u.position[1]-f.position[1],y=Math.sqrt(d*d+_*_);c.push(y)}}let m=-1*a;for(;m<(1+Mt/2)*a;)for(const h of c)m+=h,o(m)}else l.type==="CIMMarkerPlacementAtExtremities"?l.extremityPlacement===W.JustBegin?o(1):l.extremityPlacement===W.JustEnd?(o(a-1),o(-1)):l.extremityPlacement===W.Both&&(o(1),o(a-1)):l.type==="CIMMarkerPlacementOnLine"&&o(a/2)}_writeQuad(e,t,n,r,s,i=0,a=0,o=!1){const l=this.evaluatedMeshParams.sprite,{rect:c}=l,m=c.x+D,h=c.y+D,u=c.x+c.width-D,f=c.y+c.height-D,d=e.vertexCount();o||e.recordBounds(n,r,q,q);const _={texXmin:m,texYmin:h,texXmax:u,texYmax:f,value1Position2Value2:s,angle:i/_t,lineLength:a};for(let y=0;y<4;y++)this._writeVertex(e,t,n,r,_);e.indexEnsureSize(6),e.indexWrite(d),e.indexWrite(d+1),e.indexWrite(d+2),e.indexWrite(d+1),e.indexWrite(d+3),e.indexWrite(d+2)}};function wt(p){const e=[];let t=0;for(let n=1;n<p.length;n++){const r=p[n-1],s=p[n],i=s[0]-r[0],a=s[1]-r[1],o=Math.sqrt(i*i+a*a),l=i/o,c=a/o;e.push({a:{position:r,distance:t,direction:[l,c]},b:{position:s,distance:t+o,direction:[l,c]}}),t+=o}return e}let bt=class extends xe{constructor(){super(...arguments),this.shift=!1}},It=class extends xe{constructor(){super(...arguments),this.shift=!0}};class Pe extends fe{_write(e,t,n){const r=n??F.fromFeatureSetReaderCIM(t);if(!r)return;const s=this.evaluatedMeshParams.sprite,{textureBinding:i}=s;e.recordStart(this.instanceId,this.attributeLayout,i);const a=t.getDisplayId();this._writePoly(e,a,r.asOptimized()),e.recordEnd()}}let $t=class extends Pe{constructor(){super(...arguments),this.vertexSpec={createComputedParams:U,attributes:{id:J,bitset:H,pos:Q,offset:N.fill,tlbr:ye,animationPointerAndBaseSizeAndReferenceSize:Y,sizing:X},optionalAttributes:{zoomRange:K,value1Position2Value2:_e,lineLength:Ze}}}_writePoly(e,t,n){const r=[];if(!qe(r,n))return;const s=e.vertexCount();n.forEachVertex((i,a)=>{this._writeVertex(e,t,i,a)}),e.indexEnsureSize(r.length);for(const i of r)e.indexWrite(s+i)}},zt=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0}};const he=65535;class Lt extends Pe{constructor(){super(...arguments),this.vertexSpec={createComputedParams:U,attributes:{id:J,bitset:H,pos:Q,offset:N.line,tlbr:ye,animationPointerAndBaseSizeAndReferenceSize:Y,sizing:X,accumulatedDistance:We,normal:Fe,segmentDirection:Ce},optionalAttributes:{zoomRange:K,value1Position2Value2:_e,lineLength:pe}},this._tessParams=new Oe,this._currentWrite=new zt,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:he,textured:!1},this._lineLength=0,this._lineTessellator=new yt((e,t,n,r,s,i,a,o,l,c,m)=>this._writeTesselatedVertex(e,t,n,r,s,i,a,o,l,c,m,this._lineLength),this._writeTriangle.bind(this),!1)}_writePoly(e,t,n){const i=Ge(F.fromOptimized(n,"esriGeometryPolyline"),64);if(i==null)return;const{_currentWrite:a,_tessellationOptions:o}=this,{baseSize:l,capType:c,joinType:m,miterLimit:h}=this.evaluatedMeshParams,u=M(.5*l);o.halfWidth=u,o.capType=Ve(c||be.Round),o.joinType=je(m||Ie.Round),o.miterLimit=h||2,a.out=e,a.id=t,a.vertexCount=0,a.indexCount=0,a.vertexFrom=e.vertexCount(),a.vertexBounds=1;for(const{line:f,start:d,pathLength:_}of i){o.initialDistance=d%he,a.pathLength=_,this._lineLength=0;for(let y=1;y<f.length;y++){const g=f[y].x-f[y-1].x,v=f[y].y-f[y-1].y;this._lineLength+=Math.sqrt(g*g+v*v)}this._lineTessellator.tessellate(f,o,!1)}}_writeTesselatedVertex(e,t,n,r,s,i,a,o,l,c,m,h){const{out:u,id:f,vertexBounds:d,pathLength:_}=this._currentWrite;return this.hasEffects&&u.recordBounds(e,t,d,d),this._tessParams.extrusionOffsetX=a,this._tessParams.extrusionOffsetY=o,this._tessParams.normalX=l,this._tessParams.normalY=c,this._tessParams.directionX=s,this._tessParams.directionY=i,this._tessParams.distance=m,this._tessParams.pathLength=_,this._tessParams.lineLength=h,this._writeVertex(u,f,e,t,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(e,t,n){const{out:r}=this._currentWrite;r.indexEnsureSize(3),r.indexWrite(e),r.indexWrite(t),r.indexWrite(n),this._currentWrite.indexCount+=3}}const R=1,L=0,At=128;function Dt(p,e,t){return me(`${p}${e}${t}`)}function St(p,e,t,n,r){return me(`${p}${r}${e}${t*2**(B-n)}`)}const Et=$e(p=>{let e=0;if(p===0)return 1/0;for(;!(p%2);)e++,p/=2;return e});class kt extends ge{constructor(){super(...arguments),this._zoomLevel=0}_write(e,t,n,r){if(this._zoomLevel=r||0,n!=null)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(t.geometryType){case"esriGeometryPoint":{const s=t.readXForDisplay(),i=t.readYForDisplay();this._writePoint(e,s,i,0,t);break}case"esriGeometryEnvelope":case"esriGeometryPolygon":{const s=t.readCentroidForDisplay();if(!s)return;const[i,a]=s.coords;this._writePoint(e,i,a,0,t);break}case"esriGeometryMultipoint":{let s=0;const i=F.fromFeatureSetReader(t);if(i!=null&&i.nextPath())for(;i.nextPoint();)this._writePoint(e,i.x,i.y,s++,t);break}case"esriGeometryPolyline":this._writeLines(e,t)}}_getMetricDir(){const{horizontalAlignment:e,verticalAlignment:t}=this.evaluatedMeshParams;return[e==="center"?0:e==="right"?-1:1,t==="middle"?0:t==="bottom"?-1:1]}_createLineLabelMetric(e,t,n,r,s){var m,h;const[i,a]=this._getMetricDir(),o=((m=this.evaluatedMeshParams.scaleInfo)==null?void 0:m.maxScale)??0,l=((h=this.evaluatedMeshParams.scaleInfo)==null?void 0:h.minScale)??0,c=this.evaluatedMeshParams.labelClassId;return new le(e,c,t,n,r,i,a,o,l,s)}_writePoint(e,t,n,r,s){var d,_;if(t<0||t>S||n<0||n>S)return;const i=this._getShaping();if(!i)return;const a=s.getDisplayId(),o=this.evaluatedMeshParams.labelClassId,l=Dt(s.getObjectId(),o,r),[c,m]=this._getMetricDir(),h=((d=this.evaluatedMeshParams.scaleInfo)==null?void 0:d.maxScale)??0,u=((_=this.evaluatedMeshParams.scaleInfo)==null?void 0:_.minScale)??0,f=this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0};e.metricStart(new le(a,o,l,t,n,c,m,h,u,f)),this._writeGlyphs(e,a,t,n,i,0,f,void 0,!1),e.metricBoxWrite(i.boundsT),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t){const{scaleInfo:n,verticalAlignment:r}=this.evaluatedMeshParams,s=this.evaluatedMeshParams.repeatLabelDistance||128,i=this._getShaping("middle");if(!i)return;const a=(l,c,m,h)=>this._placeSubdivGlyphs(l,c,m,h),o=(i.bounds.width+s)/(1<<R);this._current={out:e,id:t.getDisplayId(),objId:t.getObjectId(),shaping:i,zoomRange:Xe(n,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null,pathIndex:0},this._verticalPlacement=r==="bottom"?"above":r==="top"?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(t,a,o):this._writeCenterAlong(t,a,o)}_writeAboveAndBelowAlong(e,t,n){const{repeatLabel:r}=this.evaluatedMeshParams,{shaping:s}=this._current,i=s.bounds.halfHeight,a=e.readGeometryForDisplay();if(!a)return;const o=new O;gt(o,a,!1,!1,"esriGeometryPolyline",1);const l=ue(new O,o,i),c=ue(new O,o,-i),m=ce(c,"esriGeometryPolyline",!1,!1),h=ce(l,"esriGeometryPolyline",!1,!1),u=G(h.paths,s.bounds.width),f=G(m.paths,s.bounds.width);this._current.offsetDirection="above";for(let d=0;d<u.length;d++)this._current.pathIndex=d,V(u[d],n,t,!!r);this._current.offsetDirection="below";for(let d=0;d<f.length;d++)this._current.pathIndex=d,V(f[d],n,t,!!r)}_writeCenterAlong(e,t,n){const{repeatLabel:r}=this.evaluatedMeshParams,{shaping:s}=this._current,i=G(e.readLegacyGeometryForDisplay().paths,s.bounds.width);for(let a=0;a<i.length;a++)this._current.pathIndex=a,V(i[a],n,t,!!r)}_placeSubdivGlyphs(e,t,n,r){const{allowOverrun:s,labelPosition:i,repeatLabelDistance:a}=this.evaluatedMeshParams,o=this._current.zoomRange[0],l=Et(t),c=this._current.shaping.bounds.width/(1<<R),m=Math.sqrt(a||At)/(1<<R),h=Math.min(n,r-n),u=this._current.shaping.isMultiline?B:Math.log2(h/(m+c/2)),f=t===0?u:Math.min(l,u),d=Math.max(o,this._zoomLevel+R-f),_=this._zoomLevel-d,y=this._current.shaping.bounds.width/2*2**_,g=St(this._current.objId,this._current.pathIndex,t,this._zoomLevel,this.evaluatedMeshParams.labelClassId);this._current.shaping.isMultiline?t===0&&this._placeStraight(e,d,g):s&&_<0?this._placeStraightAlong(e,o,g):i==="parallel"?this._placeStraightAlong(e,d,g):i==="curved"&&this._placeCurved(e,d,y,g)}_placeStraight(e,t,n){const{out:r,id:s,shaping:i,referenceBounds:a}=this._current,{x:o,y:l}=e;r.metricStart(this._createLineLabelMetric(s,n,o,l)),r.metricBoxWrite(i.boundsT);const c=e.angle*(180/Math.PI)%360,m=(e.angle*(180/Math.PI)+180)%360,h={clipAngle:c,mapAligned:!0,isLineLabel:!0,minZoom:t};this._writeGlyphs(r,s,o,l,i,0,a,h,!1);const u={clipAngle:m,mapAligned:!0,isLineLabel:!0,minZoom:t};this._writeGlyphs(r,s,o,l,i,0,a,u,!1),r.metricEnd()}_placeCurved(e,t,n,r){const{out:s,id:i}=this._current;s.metricStart(this._createLineLabelMetric(i,r,e.x,e.y));const a=e.clone(),o=e.angle*(180/Math.PI)%360,l=(e.angle*(180/Math.PI)+180)%360;this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(a,t,1,o),this._placeBack(e,a,t,n,1,o),this._placeForward(e,a,t,n,1,o)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(a,t,0,l),this._placeBack(e,a,t,n,0,l),this._placeForward(e,a,t,n,0,l)),s.metricEnd()}_placeStraightAlong(e,t,n){const{out:r,id:s,shaping:i,zoomRange:a,referenceBounds:o}=this._current,{boxBorderLineColor:l,boxBackgroundColor:c}=this.evaluatedMeshParams,m=e.clone(),h=e.angle*(180/Math.PI)%360,u=(e.angle*(180/Math.PI)+180)%360,f=i.glyphs.length>0&&!(!l&&!c);if(r.metricStart(this._createLineLabelMetric(s,n,e.x,e.y)),f){const d=Math.max(t,a[0],0),_=Math.min(B,a[1]),y=j(A(),-e.angle),g={minZoom:d,maxZoom:_,clipAngle:h,mapAligned:!0,isLineLabel:!0},v=M(this.evaluatedMeshParams.offsetX),x=M(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const b=E(v,-1*x),[I,$]=i.shapeBackground(se(A(),y,b));r.recordStart(this.instanceId,this.attributeLayout,i.glyphs[0].textureBinding),this._writeTextBox(r,s,e.x,e.y,$,o,g),r.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const b=E(v,x),[I,$]=i.shapeBackground(se(A(),y,b));g.clipAngle=u,r.recordStart(this.instanceId,this.attributeLayout,i.glyphs[0].textureBinding),this._writeTextBox(r,s,e.x,e.y,$,o,g),r.recordEnd()}}this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(m,t,1,h,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(m,t,0,u,!0),r.metricEnd()}_placeBack(e,t,n,r,s,i){const a=e.clone();let o=e.backwardLength+L;for(;a.prev()&&!(o>=r);)this._placeOnSegment(a,t,o,n,-1,s,i),o+=a.length+L}_placeForward(e,t,n,r,s,i){const a=e.clone();let o=e.remainingLength+L;for(;a.next()&&!(o>=r);)this._placeOnSegment(a,t,o,n,1,s,i),o+=a.length+L}_placeFirst(e,t,n,r,s=!1){const{out:i,id:a,shaping:o,zoomRange:l,referenceBounds:c}=this._current,m=o.glyphs,h=M(this.evaluatedMeshParams.offsetX),u=M(this.evaluatedMeshParams.offsetY),f=E(h,u),d=j(A(),-e.angle);re(f,f,d);for(const _ of m){const y=_.x>o.bounds.x?n:1-n,g=y*e.remainingLength+(1-y)*e.backwardLength,v=Math.abs(_.x+_.width/2-o.bounds.x),x=Math.max(0,this._zoomLevel+Math.log2(v/(g+L))),b=Math.max(t,s?0:x);if(_.maxZoom=Math.min(l[1],B),_.angle=e.angle+(1-n)*Math.PI,_.minZoom=Math.max(l[0],b),this._writeLineGlyph(i,a,e.x,e.y,_,r,c,!0),(n||this._current.offsetDirection)&&this._isVisible(_.minZoom,_.maxZoom)){const I=new ie(_.bounds.x+f[0],_.bounds.y+f[1],_.bounds.width,_.bounds.height);i.metricBoxWrite(I)}}}_placeOnSegment(e,t,n,r,s,i,a){const{out:o,id:l,shaping:c,referenceBounds:m}=this._current,h=c.glyphs,u=e.dx/e.length,f=e.dy/e.length,d={x:e.x+n*-s*u,y:e.y+n*-s*f},_=M(this.evaluatedMeshParams.offsetX),y=M(this.evaluatedMeshParams.offsetY),g=E(_,y),v=j(A(),-e.angle);re(g,g,v);for(const x of h){const b=x.x>c.bounds.x?i:1-i;if(!(b&&s===1||!b&&s===-1))continue;const I=Math.abs(x.x+x.width/2-c.bounds.x),$=Math.max(0,this._zoomLevel+Math.log2(I/n)-.1),Me=Math.max(r,this._zoomLevel+Math.log2(I/(n+e.length+L)));if($!==0&&(x.angle=e.angle+(1-i)*Math.PI,x.minZoom=Me,x.maxZoom=$,this._writeLineGlyph(o,l,d.x,d.y,x,a,m,!0),(i||this._current.offsetDirection)&&this._isVisible(x.minZoom,x.maxZoom))){const we=new ie(x.bounds.x+g[0],x.bounds.y+g[1],x.bounds.width,x.bounds.height);o.metricBoxWrite(we)}}}_writeLineGlyph(e,t,n,r,s,i,a,o){if(n<0||n>S||r<0||r>S)return;e.recordStart(this.instanceId,this.attributeLayout,s.textureBinding);const{texcoords:l,offsets:c}=s,{fontSize:m,haloSize:h,outlineSize:u}=this._textMeshTransformProps;this._writeQuad(e,t,n,r,{texcoords:l,offsets:c,fontSize:m,haloSize:h,outlineSize:u,color:Ye(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:a,minZoom:Math.max(this._current.zoomRange[0],s.minZoom),maxZoom:Math.min(this._current.zoomRange[1],s.maxZoom),clipAngle:i,mapAligned:o,isLineLabel:!0}),e.recordEnd()}_packedZoom(e){return Math.floor(e*ae)/ae}_isVisible(e,t){let n=Math.max(this._current.zoomRange[0],e),r=Math.min(this._current.zoomRange[1],t);n=this._packedZoom(n),r=this._packedZoom(r);const s=this._packedZoom(this._zoomLevel);return n<=s&&s<=r}}function ue(p,e,t){const{coords:n,lengths:r}=e,s=z(),i=z(),a=z(),o=z(),l=z(),c=z(),m=2;let h=0;for(let u=0;u<r.length;u++){const f=r[u];for(let d=0;d<f;d++){const _=m*(d+h-1),y=m*(d+h),g=m*(d+h+1);d>0?w(s,n[_],n[_+1]):w(s,0,0),w(i,n[y],n[y+1]),d<f-1?w(a,n[g],n[g+1]):w(a,0,0),d===0?w(o,0,0):(ne(o,i,s),Z(o,o),w(o,o[1],-o[0])),d===f-1?w(l,0,0):(ne(l,a,i),Z(l,l),w(l,l[1],-l[0])),ze(c,o,l),Z(c,c);const v=c[0]*l[0]+c[1]*l[1];v!==0&&oe(c,c,v),oe(c,c,t),p.coords.push(i[0]+c[0],i[1]+c[1])}p.lengths.push(f),h+=f}return p}class Rt extends Pt{constructor(e){super(),this._value=e}resize(e){}read(e,t){return this._value}readWithDefault(e,t,n){return this._value}hasArcadeDependency(e){return!1}}const Tt=()=>De.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");async function T(p,e,t,n){const{defaultValue:r,valueExpressionInfo:s,value:i}=e;if(s){if(s.type==="dictionary-template")return{...e,computed:p.createDictionaryTemplateField(s,t),defaultValue:r};const{expression:a}=s,o=await p.createComputedField({expression:a},n);return o?{...e,computed:o,defaultValue:r}:null}return{...e,computed:new Rt(i),defaultValue:r}}async function de(p,e,t){const{valueExpressionInfo:n}=e,r=n.type==="dictionary-template"?p.createDictionaryTemplateField(n,t):await p.createComputedField({expression:n.expression});return r?{...e,computed:r}:null}function ve(p){return typeof p=="object"&&p!=null&&(!(!("valueExpressionInfo"in p)||!p.valueExpressionInfo)||"type"in p&&p.type==="Process"&&"op"in p&&p.op==="Random")}function C(p){if(Array.isArray(p)){for(const e of p)if(C(e))return!0}if(typeof p=="object"){if(ve(p))return!0;for(const e in p)if(C(p[e]))return!0}return!1}class ee{static async create(e,t,n,r){const s={},i=new Map,a=new Map,o=new Map,l=new Map,c=new Map,m=new Map;for(const h in n){const u=n[h];if(u!=null&&typeof u=="object")if(Array.isArray(u)){if(typeof u[0]=="object")throw new Error(`InternalError: Cannot handle ${h}. Nested array params are not supported`);s[h]=u}else{if("valueExpressionInfo"in u){if(u.value){s[h]=u.value;continue}const f=await de(e,u,r);if(!f){s[h]=u.defaultValue;continue}i.set(h,f),s[h]=null;continue}switch(u.type){case"cim-effect-infos":if(u.effectInfos.some(f=>f.overrides.length)){a.set(h,{effects:await Promise.all(u.effectInfos.map(async f=>{const d=f.overrides.map(_=>T(e,_,r,!1));return{effect:f.effect,compiledOverrides:(await Promise.all(d)).filter(k)}}))});break}s[h]=u.effectInfos.map(f=>f.effect);break;case"cim-marker-placement-param":u.overrides.length&&o.set(h,{placementInfo:u,compiledOverrides:(await Promise.all(u.overrides.map(f=>T(e,f,r,!1)))).filter(k)}),s[h]=u.placement;break;case"text-rasterization-param":{if(u.overrides.length){const d=u.overrides.map(_=>T(e,_,r,u.useLegacyLabelEvaluationRules??!1));l.set(h,{compiledOverrides:(await Promise.all(d)).filter(k),rasterizationParam:u,objectIdToResourceId:new Map});continue}const f={type:"cim-rasterization-info",resource:u.resource};s[h]=await t.fetchResourceImmediate(f)??null;break}case"sprite-rasterization-param":{if(u.overrides.length){const d=u.overrides.map(_=>T(e,_,r,!1));l.set(h,{compiledOverrides:(await Promise.all(d)).filter(k),rasterizationParam:u,objectIdToResourceId:new Map});continue}if(u.resource.type==="animated"){l.set(h,{compiledOverrides:[],rasterizationParam:u,objectIdToResourceId:new Map});continue}const f={type:"cim-rasterization-info",resource:u.resource};s[h]=await t.fetchResourceImmediate(f)??null;break}case"cim-marker-transform-param":{const{params:f}=u;if(C(f)){const d={compiledMarkerInfos:[]};await Promise.all(f.map(async _=>{const y={props:{}};for(const g in _)if(ve(_[g])){const v=await de(e,_[g],r);y.compiledExpressionMap||(y.compiledExpressionMap=new Map);const x=y.compiledExpressionMap;v&&x.set(g,v)}else y.props[g]=_[g];d.compiledMarkerInfos.push(y)})),c.set(h,d)}else s[h]={type:"cim-marker-transform-info",infos:f};break}case"animation-params":{const{params:f}=u,d=Ne(f);if(C(d)){const _=await Promise.all(d.map(y=>Qe(y,e)));m.set(h,{params:_,propertyIdToResourceId:new Map,key:h})}else{const _=He(d),y=await t.fetchResourceImmediate({type:"animation-info",resource:_});y!=null&&y.type==="sprite"&&(s[h]={dataRow:y.rect.y,dataColumn:y.rect.x})}break}default:s[h]=u}}else s[h]=u}return new ee(n,s,i,a,o,l,c,m)}constructor(e,t,n,r,s,i,a,o){this.inputMeshParams=e,this._resolvedMeshParams=t,this._dynamicProperties=n,this._dynamicEffectProperties=r,this._dynamicPlacementProperties=s,this._dynamicAsyncProperties=i,this._dynamicTransformProperties=a,this._dynamicAsyncAnimations=o,this.evaluator=l=>l,this._arcadeDependencies=new Set;for(const l of this._expressions())Le(this._arcadeDependencies,l)}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,t,n){for(const r of this._dynamicAsyncProperties.values()){const s=Ae(r.rasterizationParam.resource);r.rasterizationParam.resource.type==="animated"&&r.rasterizationParam.resource.randomizeStartTime&&(s.primitiveName="__RESERVED__PRIMITIVE__NAME__",s.startGroup=Je(t.getObjectId()||0));for(const{primitiveName:a,propertyName:o,computed:l,defaultValue:c,valueExpressionInfo:m}of r.compiledOverrides)try{const h=r.rasterizationParam.resource.type==="animated"?s.primitiveName:a;xt(s,h,o,l,t,n,c)}catch(h){Tt().errorOnce(new Se("invalid-arcade-expression","Encountered an error when evaluating the arcade expression",{error:h,valueExpressionInfo:m}))}const i=e.enqueueRequest({type:"cim-rasterization-info",resource:s});r.objectIdToResourceId.set(t.getObjectId(),i)}for(const r of this._dynamicAsyncAnimations.values()){const s=r.params.map(o=>Ke(o,t,n)).map(Ue).map(o=>o.simplify()),i=et(s),a=e.enqueueRequest({type:"animation-info",resource:i});r.propertyIdToResourceId.set(t.getObjectId()+"."+r.key,a)}}evaluateMeshParams(e,t,n){for(const[r,s]of this._dynamicProperties.entries())this._resolvedMeshParams[r]=s.computed.readWithDefault(t,n,s.defaultValue);for(const[r,s]of this._dynamicPlacementProperties.entries())for(const{computed:i,defaultValue:a,propertyName:o}of s.compiledOverrides){const l=i.readWithDefault(t,n,a);s.placementInfo.placement[o]=l,this._resolvedMeshParams[r]=s.placementInfo.placement}for(const[r,s]of this._dynamicEffectProperties.entries())for(const i of s.effects){for(const{computed:a,defaultValue:o,propertyName:l}of i.compiledOverrides){const c=a.readWithDefault(t,n,o);i.effect[l]=c}this._resolvedMeshParams[r]=s.effects.map(a=>a.effect)}for(const[r,s]of this._dynamicTransformProperties.entries()){const i={type:"cim-marker-transform-info",infos:[]};for(const a of s.compiledMarkerInfos){const o={...a.props};if(a.compiledExpressionMap)for(const[l,c]of a.compiledExpressionMap){const m=c.computed.readWithDefault(t,n,c.defaultValue);o[l]=typeof m=="number"||typeof m=="boolean"?m:c.defaultValue}i.infos.push(o)}this._resolvedMeshParams[r]=i}for(const[r,s]of this._dynamicAsyncProperties.entries()){const i=s.objectIdToResourceId.get(t.getObjectId());if(i==null)continue;const a=e.getResource(i);this._resolvedMeshParams[r]=a}for(const[r,s]of this._dynamicAsyncAnimations.entries()){const i=s.propertyIdToResourceId.get(t.getObjectId()+"."+r);if(i==null)continue;const a=e.getResource(i);this._resolvedMeshParams[r]={dataRow:a.rect.y,dataColumn:a.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}hasArcadeDependency(e){return this._arcadeDependencies.has(e)}*_expressions(){for(const e of this._dynamicProperties.values())yield e.computed;for(const e of this._dynamicEffectProperties.values())for(const t of e.effects)for(const n of t.compiledOverrides)yield n.computed;for(const e of this._dynamicPlacementProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicAsyncProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicTransformProperties.values())for(const t of e.compiledMarkerInfos)if(t.compiledExpressionMap!=null)for(const n of t.compiledExpressionMap.values())yield n.computed;for(const e of this._dynamicAsyncAnimations.values())for(const t of e.params)yield*tt(t)}}class Qt{async createMeshWriter(e,t,n,r,s){const i=this._getMeshWriter(r.techniqueType),a=await ee.create(e,t,r.inputParams,s),o=new i(r.id,a,r.optionalAttributes,n);return await o.loadDependencies(),o}_getMeshWriter(e){switch(e){case P.Fill:return pt;case P.DotDensity:return ft;case P.ComplexFill:return mt;case P.PatternFill:return dt;case P.GradientFill:return ut;case P.OutlineFill:return ht;case P.PatternOutlineFill:return lt;case P.ComplexOutlineFill:return ct;case P.Marker:return ot;case P.PieChart:return nt;case P.Text:return ge;case P.Line:return at;case P.TexturedLine:return it;case P.GradientStroke:return rt;case P.Heatmap:return st;case P.Label:return kt;case P.AnimatedMarker:return bt;case P.AnimatedMarkerShift:return It;case P.AnimatedFill:return $t;case P.AnimatedLine:return Lt;default:throw new Error("Internal Error: Mesh writer not in the registry")}}}export{Rt as r,Qt as y};
