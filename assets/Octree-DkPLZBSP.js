import{e7 as v,bo as U,aR as _,bH as ae,aP as W,fJ as le,fI as V,fH as $,fG as q}from"./index-Btyj_e22.js";import{s as C}from"./frustum-By6vgkJi.js";import{w as J,k as Q,N as k,H as X,E as D,U as f}from"./sphere-BWM9spN1.js";import{i as ne}from"./BufferView-CYbRrMZQ.js";class B{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(e,t){this.objectToBoundingSphere=e,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new d,this._objectCount=0,t&&(t.maximumObjectsPerNode!==void 0&&(this._maximumObjectsPerNode=t.maximumObjectsPerNode),t.maximumDepth!==void 0&&(this._maximumDepth=t.maximumDepth))}destroy(){this._degenerateObjects.clear(),d.clearPool(),K[0]=null,M.prune(),A.prune()}add(e){const t=Array.from(e);this._grow(t);const n=d.acquire();for(const o of t)++this._objectCount,this._isDegenerate(o)?this._degenerateObjects.add(o):(n.init(this._root),this._add(o,n));d.release(n)}remove(e,t=null){this._objectCount-=e.length;const n=d.acquire();for(const o of e){const h=t??J(this.objectToBoundingSphere(o),Se);E(h[3])?(n.init(this._root),ue(o,h,n)):this._degenerateObjects.delete(o)}d.release(n),this._shrink()}update(e,t){if(!E(t[3])&&this._isDegenerate(e))return;const n=be(e);this.remove(n,t),this.add(n)}forEachAlongRay(e,t,n){const o=Q(e,t);N(this._root,h=>{if(!ce(o,h))return!1;const r=h.node;return r.terminals.forAll(a=>{this._intersectsObject(o,a)&&n(a)}),r.residents!==null&&r.residents.forAll(a=>{this._intersectsObject(o,a)&&n(a)}),!0})}forEachAlongRayWithVerticalOffset(e,t,n,o){const h=Q(e,t);N(this._root,r=>{if(!fe(h,r,o))return!1;const a=r.node;return a.terminals.forAll(s=>{this._intersectsObjectWithOffset(h,s,o)&&n(s)}),a.residents!==null&&a.residents.forAll(s=>{this._intersectsObjectWithOffset(h,s,o)&&n(s)}),!0})}forEach(e){N(this._root,t=>{const n=t.node;return n.terminals.forAll(e),n.residents!==null&&n.residents.forAll(e),!0}),this._degenerateObjects.forEach(e)}forEachDegenerateObject(e){this._degenerateObjects.forEach(e)}findClosest(e,t,n,o=()=>!0,h=1/0){let r=1/0,a=1/0,s=null;const u=H(e,t),m=l=>{if(--h,!o(l))return;const p=this.objectToBoundingSphere(l);if(!C(n,p))return;const O=z(e,t,f(p)),R=O-p[3],c=O+p[3];R<r&&(r=R,a=c,s=l)};return Y(this._root,l=>{if(h<=0||!C(n,l.bounds)||($(g,u,l.halfSize),q(g,g,f(l.bounds)),z(e,t,g)>a))return!1;const p=l.node;return p.terminals.forAll(O=>m(O)),p.residents!==null&&p.residents.forAll(O=>m(O)),!0},e,t),s}forEachInDepthRange(e,t,n,o,h,r,a){let s=-1/0,u=1/0;const m={setRange:c=>{n===B.DepthOrder.FRONT_TO_BACK?(s=Math.max(s,c.near),u=Math.min(u,c.far)):(s=Math.max(s,-c.far),u=Math.min(u,-c.near))}};m.setRange(o);const l=z(t,n,e),p=H(t,n),O=H(t,-n),R=c=>{if(!a(c))return;const T=this.objectToBoundingSphere(c),F=f(T),G=z(t,n,F)-l,re=G-T[3],he=G+T[3];re>u||he<s||!C(r,T)||h(c,m)};Y(this._root,c=>{if(!C(r,c.bounds)||($(g,p,c.halfSize),q(g,g,f(c.bounds)),z(t,n,g)-l>u)||($(g,O,c.halfSize),q(g,g,f(c.bounds)),z(t,n,g)-l<s))return!1;const T=c.node;return T.terminals.forAll(F=>R(F)),T.residents!==null&&T.residents.forAll(F=>R(F)),!0},t,n)}forEachNode(e){N(this._root,t=>e(t.node,t.bounds,t.halfSize,t.depth))}forEachNeighbor(e,t){const n=k(t),o=f(t),h=s=>{const u=this.objectToBoundingSphere(s),m=k(u),l=n+m;return!(V(f(u),o)-l*l<=0)||e(s)};let r=!0;const a=s=>{r&&(r=h(s))};N(this._root,s=>{const u=k(s.bounds),m=n+u;if(V(f(s.bounds),o)-m*m>0)return!1;const l=s.node;return l.terminals.forAll(a),r&&l.residents!==null&&l.residents.forAll(a),r}),r&&this.forEachDegenerateObject(a)}_intersectsObject(e,t){const n=this.objectToBoundingSphere(t);return!(n[3]>0)||X(n,e)}_intersectsObjectWithOffset(e,t,n){const o=this.objectToBoundingSphere(t);return!(o[3]>0)||X(n.applyToBoundingSphere(o),e)}_add(e,t){t.advanceTo(this.objectToBoundingSphere(e))?t.node.terminals.push(e):(t.node.residents.push(e),t.node.residents.length>this._maximumObjectsPerNode&&t.depth<this._maximumDepth&&this._split(t))}_split(e){const t=e.node.residents;e.node.residents=null;for(let n=0;n<t.length;n++){const o=d.acquire().init(e);this._add(t.at(n),o),d.release(o)}}_grow(e){if(Z(e,t=>this.objectToBoundingSphere(t),x),E(x[3])&&!this._fitsInsideTree(x))if(oe(this._root.node))J(x,this._root.bounds),this._root.halfSize=1.25*this._root.bounds[3],this._root.updateBoundsRadiusFromHalfSize();else{const t=this._rootBoundsForRootAsSubNode(x);this._placingRootViolatesMaxDepth(t)?this._rebuildTree(x,t):this._growRootAsSubNode(t),d.release(t)}}_rebuildTree(e,t){U(f(I),f(t.bounds)),I[3]=t.halfSize,Z([e,I],o=>o,L);const n=d.acquire().init(this._root);this._root.initFrom(null,L,L[3]),this._root.increaseHalfSize(1.25),N(n,o=>(this.add(o.node.terminals.data),o.node.residents!==null&&this.add(o.node.residents.data),!0)),d.release(n)}_placingRootViolatesMaxDepth(e){const t=Math.log(e.halfSize/this._root.halfSize)*Math.LOG2E;let n=0;return N(this._root,o=>(n=Math.max(n,o.depth),n+t<=this._maximumDepth)),n+t>this._maximumDepth}_rootBoundsForRootAsSubNode(e){const t=e[3],n=e;let o=-1/0;const h=this._root.bounds,r=this._root.halfSize;for(let s=0;s<3;s++){const u=h[s]-r-(n[s]-t),m=n[s]+t-(h[s]+r),l=Math.max(0,Math.ceil(u/(2*r))),p=Math.max(0,Math.ceil(m/(2*r)))+1,O=2**Math.ceil(Math.log(l+p)*Math.LOG2E);o=Math.max(o,O),w[s].min=l,w[s].max=p}for(let s=0;s<3;s++){let u=w[s].min,m=w[s].max;const l=(o-(u+m))/2;u+=Math.ceil(l),m+=Math.floor(l);const p=h[s]-r-u*r*2;y[s]=p+(m+u)*r}const a=o*r;return y[3]=a*se,d.acquire().initFrom(null,y,a,0)}_growRootAsSubNode(e){const t=this._root.node;U(f(x),f(this._root.bounds)),x[3]=this._root.halfSize,this._root.init(e),e.advanceTo(x,null,!0),e.node.children=t.children,e.node.residents=t.residents,e.node.terminals=t.terminals}_shrink(){for(;;){const e=this._findShrinkIndex();if(e===-1)break;this._root.advance(e),this._root.depth=0}}_findShrinkIndex(){if(this._root.node.terminals.length!==0||this._root.isLeaf())return-1;let e=null;const t=this._root.node.children;let n=0,o=0;for(;o<t.length&&e==null;)n=o++,e=t[n];for(;o<t.length;)if(t[o++])return-1;return n}_isDegenerate(e){return!E(this.objectToBoundingSphere(e)[3])}_fitsInsideTree(e){const t=this._root.bounds,n=this._root.halfSize;return e[3]<=n&&e[0]>=t[0]-n&&e[0]<=t[0]+n&&e[1]>=t[1]-n&&e[1]<=t[1]+n&&e[2]>=t[2]-n&&e[2]<=t[2]+n}toJSON(){const{maximumDepth:e,maximumObjectsPerNode:t,_objectCount:n}=this,o=this._nodeToJSON(this._root.node);return{maximumDepth:e,maximumObjectsPerNode:t,objectCount:n,root:{bounds:this._root.bounds,halfSize:this._root.halfSize,depth:this._root.depth,node:o}}}_nodeToJSON(e){var h,r;const t=e.children.map(a=>a?this._nodeToJSON(a):null),n=(h=e.residents)==null?void 0:h.map(a=>this.objectToBoundingSphere(a)),o=(r=e.terminals)==null?void 0:r.map(a=>this.objectToBoundingSphere(a));return{children:t,residents:n,terminals:o}}static fromJSON(e){const t=new B(n=>n,{maximumDepth:e.maximumDepth,maximumObjectsPerNode:e.maximumObjectsPerNode});return t._objectCount=e.objectCount,t._root.initFrom(e.root.node,e.root.bounds,e.root.halfSize,e.root.depth),t}}const j=class j{constructor(){this.bounds=D(),this.halfSize=0,this.initFrom(null,null,0,0)}init(e){return this.initFrom(e.node,e.bounds,e.halfSize,e.depth)}initFrom(e,t,n,o=this.depth){return this.node=e??j.createEmptyNode(),t&&J(t,this.bounds),this.halfSize=n,this.depth=o,this}increaseHalfSize(e){this.halfSize*=e,this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds[3]=this.halfSize*se}advance(e){let t=this.node.children[e];t||(t=j.createEmptyNode(),this.node.children[e]=t),this.node=t,this.halfSize/=2,this.depth++;const n=ie[e];return this.bounds[0]+=n[0]*this.halfSize,this.bounds[1]+=n[1]*this.halfSize,this.bounds[2]+=n[2]*this.halfSize,this.updateBoundsRadiusFromHalfSize(),this}advanceTo(e,t,n=!1){for(;;){if(this.isTerminalFor(e))return t&&t(this,-1),!0;if(this.isLeaf()){if(!n)return t&&t(this,-1),!1;this.node.residents=null}const o=this._childIndex(e);t&&t(this,o),this.advance(o)}}isLeaf(){return this.node.residents!=null}isTerminalFor(e){return e[3]>this.halfSize/2}_childIndex(e){const t=this.bounds;return(t[0]<e[0]?1:0)+(t[1]<e[1]?2:0)+(t[2]<e[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new v({shrink:!0}),residents:new v({shrink:!0})}}static acquire(){return j._pool.acquire()}static release(e){j._pool.release(e)}static clearPool(){j._pool.prune()}};j._pool=new ae(j);let d=j;function N(i,e){let t=d.acquire().init(i);const n=[t];for(;n.length!==0;){if(t=n.pop(),e(t)&&!t.isLeaf())for(let o=0;o<t.node.children.length;o++)t.node.children[o]&&n.push(d.acquire().init(t).advance(o));d.release(t)}}function Y(i,e,t,n=B.DepthOrder.FRONT_TO_BACK){let o=d.acquire().init(i);const h=[o];for(pe(t,n,te);h.length!==0;){if(o=h.pop(),e(o)&&!o.isLeaf())for(let r=7;r>=0;--r){const a=te[r];o.node.children[a]&&h.push(d.acquire().init(o).advance(a))}d.release(o)}}function ue(i,e,t){M.clear();const n=t.advanceTo(e,(o,h)=>{M.push(o.node),M.push(h)})?t.node.terminals:t.node.residents;if(n.removeUnordered(i),n.length===0)for(let o=M.length-2;o>=0&&de(M.data[o],M.data[o+1]);o-=2);}function de(i,e){return e>=0&&(i.children[e]=null),!!oe(i)&&(i.residents===null&&(i.residents=new v({shrink:!0})),!0)}function ce(i,e){return P(f(e.bounds),2*-e.halfSize,b),P(f(e.bounds),2*e.halfSize,S),ne(i.origin,i.direction,b,S)}function fe(i,e,t){return P(f(e.bounds),2*-e.halfSize,b),P(f(e.bounds),2*e.halfSize,S),t.applyToMinMax(b,S),ne(i.origin,i.direction,b,S)}function oe(i){if(i.terminals.length!==0)return!1;if(i.residents!==null)return i.residents.length===0;for(let e=0;e<i.children.length;e++)if(i.children[e])return!1;return!0}function me(i,e){i[0]=Math.min(i[0],e[0]-e[3]),i[1]=Math.min(i[1],e[1]-e[3]),i[2]=Math.min(i[2],e[2]-e[3])}function _e(i,e){i[0]=Math.max(i[0],e[0]+e[3]),i[1]=Math.max(i[1],e[1]+e[3]),i[2]=Math.max(i[2],e[2]+e[3])}function P(i,e,t){t[0]=i[0]+e,t[1]=i[1]+e,t[2]=i[2]+e}function Z(i,e,t){b[0]=1/0,b[1]=1/0,b[2]=1/0,S[0]=-1/0,S[1]=-1/0,S[2]=-1/0;for(const n of i){const o=e(n);E(o[3])&&(me(b,o),_e(S,o))}le(f(t),b,S,.5),t[3]=Math.max(S[0]-b[0],S[1]-b[1],S[2]-b[2])/2}function pe(i,e,t){if(!A.length)for(let n=0;n<8;++n)A.push({index:0,distance:0});for(let n=0;n<8;++n){const o=ie[n];A.data[n].index=n,A.data[n].distance=z(i,e,o)}A.sort((n,o)=>n.distance-o.distance);for(let n=0;n<8;++n)t[n]=A.data[n].index}function H(i,e){let t,n=1/0;for(let o=0;o<8;++o){const h=z(i,e,ee[o]);h<n&&(n=h,t=ee[o])}return t}function z(i,e,t){return e*(i[0]*t[0]+i[1]*t[1]+i[2]*t[2])}function E(i){return!isNaN(i)&&i!==-1/0&&i!==1/0&&i>0}(function(i){var e;(e=i.DepthOrder||(i.DepthOrder={}))[e.FRONT_TO_BACK=1]="FRONT_TO_BACK",e[e.BACK_TO_FRONT=-1]="BACK_TO_FRONT"})(B||(B={}));const ie=[_(-1,-1,-1),_(1,-1,-1),_(-1,1,-1),_(1,1,-1),_(-1,-1,1),_(1,-1,1),_(-1,1,1),_(1,1,1)],ee=[_(-1,-1,-1),_(-1,-1,1),_(-1,1,-1),_(-1,1,1),_(1,-1,-1),_(1,-1,1),_(1,1,-1),_(1,1,1)],se=Math.sqrt(3),K=[null];function be(i){return K[0]=i,K}const y=D(),g=W(),b=W(),S=W(),M=new v,Se=D(),x=D(),I=D(),L=D(),w=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],A=new v,te=[0,0,0,0,0,0,0,0];export{B as b};
