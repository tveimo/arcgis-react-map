const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/geometryEngineJSON-BVpgM-_G.js","assets/geometryEngineBase-E1PPqbft.js","assets/_commonjsHelpers-DCkdB7M8.js","assets/json-Wa8cmqdu.js"])))=>i.map(i=>d[i]);
import{ss as ve,h7 as H,cm as yt,h6 as gt,cl as _t,ep as jt,am as Jt,s as Pe,st as Ot,su as Yt,sv as Bt,nn as I,sw as we,_ as Te,f3 as u,kj as Me,nz as st,cp as b,qr as Kt,qc as te,bx as $e,nq as lt,el as y,hv as Ee,a4 as Ae,sx as ze,bp as Ie,sy as ut,sz as ht,sA as ee,du as Ct,sB as De,sC as Le,sD as Fe,sE as Ne,sF as Oe,sG as Ye,sH as Be,sI as se,sJ as Ce,no as rt,nx as nt,nv as Re,sK as Ge,nw as We,sL as Ue}from"./index-cGsjYgnw.js";import{o as E,y as C,r as kt,e as Rt,a as St}from"./UpdateTracking2D-BAT2JbCa.js";import{C as He,q as ie,B as re,M as Xe,K as pt,L as Gt,F as Ve,H as Ze,D as qe,E as Qe}from"./constants-BFLErLYb.js";import{a as je,c as Je,i as Ke}from"./libtess-_ffR5DlL.js";import{t as ts,d as es,f as ss,g as ne}from"./Utils-BRojpG24.js";import"./earcut-D9gy186-.js";let oe=class{static getPlacement(t,e,r,i,n,o){const a=ve(r);return a?(e===-1&&t.invertY(),a.execute(t,r,i,n,o)):null}};const is=()=>Jt.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils"),rs=0,ns=100;function Z(s,t){return[!!(s!=null&&s.minScale)&&t.scaleToZoom(s.minScale)||rs,!!(s!=null&&s.maxScale)&&t.scaleToZoom(s.maxScale)||ns]}function w(s){return 1<<s}function q(s){let t=0;for(const[e,r]of s)r&&(t|=1<<e);return t}function _(s){let t;if(!s)return[0,0,0,0];if(typeof s=="string"){const o=jt.fromString(s);if(!o)return is().errorOnce(new Pe("mapview:mesh-processing","Unable to parse string into color",{color:s})),[0,0,0,0];t=o.toArray()}else t=s;const[e,r,i,n]=t;return[e*(n/255),r*(n/255),i*(n/255),n]}function os(s){switch(s){case"butt":case H.Butt:return yt.BUTT;case"round":case H.Round:return yt.ROUND;case"square":case H.Square:return yt.SQUARE}}function as(s){switch(s){case"bevel":case gt.Bevel:return _t.BEVEL;case"miter":case gt.Miter:return _t.MITER;case"round":case gt.Round:return _t.ROUND}}function bt(s,t){return Math.round(Math.min(Math.sqrt(s*t),255))}function ot(s,t){return Math.round(s*t)/t}const cs=96/72;let ls=class{static executeEffects(t,e,r,i,n){const o=cs,a=Ot(t);let c=new Bt(e);for(const l of t){const h=Yt(l);h&&(c=h.execute(c,l,o,r,i,a,n))}return c}static applyEffects(t,e,r){if(!t)return e;const i=Ot(t);let n,o=new Bt(I.fromJSONCIM(e));for(const l of t){const h=Yt(l);h&&(o=h.execute(o,l,1,null,r,i,!1))}const a=[];let c=null;for(;n=o.next();)a.push(...we(n)),c=n.geometryType;return a.length===0||c===null?null:c==="esriGeometryPolygon"?{rings:a}:{paths:a}}},ae=null;function zt(){return ae}async function us(){ae=await Te(()=>import("./geometryEngineJSON-BVpgM-_G.js").then(s=>s.g),__vite__mapDeps([0,1,2,3]))}function ce(s){switch(s){case u.BYTE:case u.UNSIGNED_BYTE:return 1;case u.SHORT:case u.UNSIGNED_SHORT:case u.HALF_FLOAT:return 2;case u.FLOAT:case u.INT:case u.UNSIGNED_INT:return 4}}function hs(s){const t=[],e=[],r=[];for(const i of s){const n=ce(i.type)*i.count;switch(n%2||n%4||4){case 4:t.push(i);continue;case 2:e.push(i);continue;case 1:r.push(i);continue;default:throw new Error("Found unexpected dataType byte count")}}return t.push(...e),t.push(...r),t}let ps=class le{static fromVertexSpec(t,e){const{attributes:r,optionalAttributes:i}=t;let n,o,a;const c=[];for(const m in r){if(r[m].otherSource)continue;const g=r[m];g.pack==="position"?n={...g,name:m,offset:0}:g.pack==="id"?o={...g,name:m,offset:4}:m==="bitset"?a={...g,name:m,offset:7}:c.push({...g,name:m})}for(const m in i)if(e[m]===!0){const g=i[m];c.push({...g,name:m})}const l=hs(c),h=[];let p=8,x=1;for(const m of l)h.push({...m,offset:p}),p+=ce(m.type)*m.count,m.packAlternating&&(x=Math.max(m.packAlternating.count,x));const d=Uint32Array.BYTES_PER_ELEMENT,f=p%d;return new le(n,o,a,h,p+(f?d-f:0),x)}constructor(t,e,r,i,n,o){this.position=t,this.id=e,this.bitset=r,this.standardAttributes=i,this.stride=n,this.packVertexCount=o,i.push(r),this._attributes=[t,e,r,...i]}get attributeLayout(){if(!this._attributeLayout){const t=ts(this._attributes),e=this._attributes.map(r=>({name:r.name,count:r.count,offset:r.offset,type:r.type,packPrecisionFactor:r.packPrecisionFactor,normalized:r.normalized??!1}));this._attributeLayout={attributes:e,hash:t,stride:this.stride}}return this._attributeLayout}},fs=class ue{static fromVertexSpec(t,e){const r=ps.fromVertexSpec(t,e);return new ue(r)}constructor(t){this._spec=t,this._packed=new Uint8Array(this._spec.stride*this._spec.packVertexCount),this._packedU32View=new Uint32Array(this._packed.buffer),this._dataView=new DataView(this._packed.buffer)}get attributeLayout(){return this._spec.attributeLayout}get stride(){return this._spec.stride}writeVertex(t,e,r,i,n,o){var a;for(let c=0;c<this._spec.packVertexCount;c++){const l=c*this._spec.stride;this._packPosition(r,i,l),this._packId(e,l);const h=this._spec.bitset;if(o){if(h.packTessellation){const p=h.packTessellation(o,n,r,i);this._pack(p,h,l)}for(const p of this._spec.standardAttributes)if(p.packTessellation!=null){const x=p.packTessellation(o,n,r,i);this._pack(x,p,l)}else if((a=p.packAlternating)!=null&&a.packTessellation){const x=p.packAlternating.packTessellation(o,n,r,i);for(let d=0;d<this._spec.packVertexCount;d++){const f=x[d];this._pack(f,p,d*this._spec.stride)}}}}t.vertexWriteRegion(this._packedU32View)}pack(t,e){var r;for(const i of this._spec.standardAttributes)if(i.pack&&typeof i.pack!="string"){const n=i.pack(t,e);for(let o=0;o<this._spec.packVertexCount;o++)this._pack(n,i,o*this._spec.stride)}else if((r=i.packAlternating)!=null&&r.pack){const n=i.packAlternating.pack(t,e);for(let o=0;o<this._spec.packVertexCount;o++){const a=n[o];this._pack(a,i,o*this._spec.stride)}}}_packPosition(t,e,r){const{offset:i}=this._spec.position,n=this._spec.position.packPrecisionFactor??1,o=es(t*n,e*n);this._dataView.setUint32(r+i,o,!0)}_packId(t,e){const r=t*(this._spec.id.packPrecisionFactor??1),i=4278190080&this._dataView.getUint32(e+this._spec.id.offset,!0);this._dataView.setUint32(e+this._spec.id.offset,r|i,!0)}_pack(t,e,r){ss(this._dataView,t,e,r)}};function ds(s){if(!s)return!1;for(const t of s)switch(t.effect.type){case"CIMGeometricEffectBuffer":case"CIMGeometricEffectDonut":case"CIMGeometricEffectOffset":case"CIMGeometricEffectTaperedPolygon":case"CIMGeometricEffectEnclosingPolygon":return!0}return!1}let G=class{constructor(t,e,r,i){this._instanceId=t,this._evaluator=e,this._enabledOptionalAttributes=r,this._viewParams=i,this._evaluator.evaluator=n=>this.vertexSpec.createComputedParams(n)}get _vertexPack(){if(!this._cachedVertexPack){const t=fs.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||t.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=t}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get effectInfos(){var t;return(t=this._evaluator.inputMeshParams.effects)==null?void 0:t.effectInfos}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}get _preventEffectClipping(){return!1}setReferences(t){this._references=t}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){ds(this.effectInfos)&&await us()}enqueueRequest(t,e,r){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest(t,e,r)}write(t,e,r,i,n){this.ensurePacked(e,r,i);const o=this.evaluatedMeshParams.effects;if(!o||o.length===0)return void this._write(t,r,void 0,n);const a=this.getEffectCursor(t,r,o);if(!a)return;let c;for(;c=a.next();)c.invertY(),this._write(t,r,c,n)}ensurePacked(t,e,r){if(!this._evaluator.hasDynamicProperties)return;const i=this._evaluator.evaluateMeshParams(t,e,r);this._vertexPack.pack(i,this._viewParams)}hasArcadeDependency(t){return this._evaluator.hasArcadeDependency(t)}_writeVertex(t,e,r,i,n){const o=this.evaluatedMeshParams;this._vertexPack.writeVertex(t,e,r,i,o,n)}getEffectCursor(t,e,r){var c;const i=(c=e.readGeometryForDisplay())==null?void 0:c.clone();if(!i)return;const n=I.fromOptimizedCIM(i,e.geometryType),o=zt();n.invertY();const a=t.id||"";return ls.executeEffects(r,n,a,o,this._preventEffectClipping)}},Ri=class extends G{};function xs(s){const{sprite:t,isMapAligned:e,colorLocked:r,scaleSymbolsProportionally:i,isStroke:n}=s;let o=0;return e&&(o|=w(E.bitset.isMapAligned)),r&&(o|=w(E.bitset.colorLocked)),t.sdf&&(o|=w(E.bitset.isSDF)),i&&(o|=w(E.bitset.scaleSymbolsProportionally)),n&&(o|=w(E.bitset.isStroke)),o}function he(s,t){let e;if(typeof s=="string")e=Me(s+`-seed(${t})`);else{let r=12;e=s^t;do e=107*(e>>8^e)+r|0;while(--r!==0)}return(1+e/(1<<31))/2}function ms(s){return Math.floor(he(s,ys)*gs)}const ys=53290320,gs=10;function mt(s){return s instanceof it?s:typeof s=="object"&&"type"in s?bs[s.type].hydrate(s):new X(s)}let it=class{constructor(t){this.inputs=t}encode(){const t=[];for(const e of this.inputs)t.push(...e.encode());return t.push(...this.instructions),t}},X=class extends it{constructor(t){super([]),this.value=t}simplify(){return this}get instructions(){if(Array.isArray(this.value)){const[t,e,r,i]=this.value;return i!=null?C.vector4.encode([t,e||0,r||0,i]):C.vector3.encode([t,e||0,r||0])}return C.scalar.encode(this.value)}},_s=class vt extends it{constructor(t,e){super([e]),this._config=t,this._parent=e}static hydrate(t){return new vt(t,mt(t.parent))}simplify(){if(this._config.relativeTranslation||this._config.absoluteScale)return this;const t=this._parent.simplify();if(!(t instanceof X))return this;const[e,r,i,n]=t.value,o=this._config.translation.from[0],a=this._config.translation.from[1],c=this._config.rotation.from,l=this._config.scale.from;if(o===this._config.translation.to[0]&&a===this._config.translation.to[1]&&c===this._config.rotation.to&&l===this._config.scale.to){const h=i+c,p=n*l,x=Math.sin(i),d=Math.cos(i);return new X([d*n*o-x*n*a+e,x*n*o+d*n*a+r,h,p])}return new vt(this._config,t)}get instructions(){return C.animatedTransform.encode(this._config)}},ks=class Pt extends it{constructor(t,e){super([e]),this._config=t,this._parent=e}static hydrate(t){return new Pt(t,mt(t.parent))}simplify(){const t=this._parent.simplify();if(!(t instanceof X))return this;const[e,r,i,n]=t.value,o=this._config.color.from[0],a=this._config.color.from[1],c=this._config.color.from[2];let l=this._config.color.from[3];const h=this._config.opacity.from;return o===this._config.color.to[0]&&a===this._config.color.to[1]&&c===this._config.color.to[2]&&l===this._config.color.to[3]&&h===this._config.opacity.to?(l*=h,new X([e*o,r*a,i*c,n*l])):new Pt(this._config,t)}get instructions(){return C.animatedColor.encode(this._config)}},Ss=class wt extends it{constructor(t,e){super([e]),this._config=t,this._parent=e}static hydrate(t){return new wt(t,mt(t.parent))}simplify(){const t=this._parent.simplify();return t instanceof X?new wt(this._config,t):this}get instructions(){return C.animatedShift.encode(this._config)}};const bs={AnimatedTransform:_s,AnimatedColor:ks,AnimatedShift:Ss};function Hi(s){return vs(s.map(t=>S(t)).map(t=>mt(t).simplify()))}function Xi(s){const t=[];return t.push(s.transform),t.push(s.fromColor),t.push(s.toColor),t.push(s.colorMix),t.push(s.toOpacity),t.push(s.opacityMix),s!=null&&s.shift?t.push(s==null?void 0:s.shift):t.push([1,1,1,1]),t}function vs(s){const t=[],e=[];let r=0;for(const i of s){const n=[...i.encode(),...C.ret.encode()];t.push([r+s.length,0,0,0]),e.push(...n),r+=n.length}return[...t,...e]}async function Wt(s,t){const e=s;let r;if(typeof e=="number"||typeof e=="string"||typeof e=="boolean")r=e;else if(Array.isArray(e))r=await Promise.all(e.map(i=>Wt(i,t)));else if(typeof e=="object")if("valueExpressionInfo"in e){const{valueExpressionInfo:i}=e,{expression:n}=i;r={...e,computed:await t.createComputedField({expression:n})}}else{r={};for(const i in e)r[i]=await Wt(e[i],t)}return r}function S(s,t,e){function r(o){if(!("computed"in o))return o;let a=o.computed.readWithDefault(t,e,[255*o.defaultValue[0],255*o.defaultValue[1],255*o.defaultValue[2],o.defaultValue[3]]);if(typeof a=="string"){const c=jt.fromString(a);c&&(a=[c.r,c.g,c.b,c.a])}return a}const i=s;let n;if(typeof i=="number"||typeof i=="string"||typeof i=="boolean")n=i;else if(Array.isArray(i))n=i.map(o=>S(o,t,e));else if(typeof i=="object")if("type"in i&&i.type!=null&&i.type==="Process")switch(i.op){case"ArcadeColor":{const o=S(i.value,t,e);Q(Array.isArray(o)&&o.length===4),n=[o[0]/255,o[1]/255,o[2]/255,o[3]]}break;case"Transparency":{const o=S(i.value,t,e);Q(typeof o=="number"),n=1-o/100}break;case"Divide":case"Multiply":case"Add":{const o=S(i.left,t,e);Q(typeof o=="number");const a=S(i.right,t,e);switch(Q(typeof a=="number"),i.op){case"Divide":n=o/a;break;case"Multiply":n=o*a;break;case"Add":n=o+a}}break;case"Random":{const o=S(i.seed,t,e),a=S(i.min,t,e),c=S(i.max,t,e),l=t.getObjectId(),h=ms(l||0);n=a+he(h,o)*(c-a)}break;case"Cond":{const o=S(i.condition,t,e),a=S(i.ifTrue,t,e),c=S(i.ifFalse,t,e);n=o?a:c}break;case"MatchWinding":{const o=S(i.sign,t,e);let a=S(i.angle,t,e);if(o>0)for(;a<0;)a+=2*Math.PI;else for(;a>0;)a-=2*Math.PI;n=a}}else if("computed"in i)n=r(i);else{n={};for(const o in i)n[o]=S(i[o],t,e)}return n}function*P(s){const t=s;if(Array.isArray(t))for(const e of t)yield*P(e);else if(typeof t=="object")if("type"in t&&t.type!=null&&t.type==="Process")switch(t.op){case"ArcadeColor":case"Transparency":yield*P(t.value);break;case"Divide":case"Multiply":case"Add":yield*P(t.left),yield*P(t.right);break;case"Random":yield*P(t.seed),yield*P(t.min),yield*P(t.max);break;case"Cond":yield*P(t.condition),yield*P(t.ifTrue),yield*P(t.ifFalse);break;case"MatchWinding":yield*P(t.sign),yield*P(t.angle)}else if("computed"in t)yield t.computed;else for(const e in t)yield*P(t[e])}function Q(s){if(!s)throw new Error("Assertion failed.")}const Vi={type:u.SHORT,count:2,packPrecisionFactor:st,pack:({scaleInfo:s},{tileInfo:t})=>Z(s,t)},Zi={type:u.FLOAT,count:4,packPrecisionFactor:1,packTessellation:({value1Position2Value2:s})=>(Q(s),s)},qi={type:u.FLOAT,count:4,packPrecisionFactor:1,packTessellation:()=>[0,0,0,1]},Qi={type:u.FLOAT,count:1,packPrecisionFactor:1,pack:()=>0},ji={type:u.FLOAT,count:1,packPrecisionFactor:1,packTessellation:({lineLength:s})=>s},Ji={type:u.UNSIGNED_SHORT,count:1,packTessellation:({distance:s})=>s},Ki={type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:s,directionY:t})=>[s,t]},tr={type:u.FLOAT,count:2,packPrecisionFactor:16,packTessellation:({normalX:s,normalY:t})=>[s,t]},er={type:u.UNSIGNED_BYTE,count:3,pack:"id"},sr={type:u.UNSIGNED_BYTE,count:1,pack:xs},ir={type:u.SHORT,count:2,pack:"position",packPrecisionFactor:1},rr={marker:{type:u.FLOAT,count:2,packAlternating:{count:4,pack:({texelDimensions:s})=>[[-.5*s[0],-.5*s[1]],[.5*s[0],-.5*s[1]],[-.5*s[0],.5*s[1]],[.5*s[0],.5*s[1]]]}},line:{type:u.FLOAT,count:2,packTessellation:({extrusionOffsetX:s,extrusionOffsetY:t},{baseSize:e})=>[s*e/2,t*e/2]},fill:{type:u.FLOAT,count:2,packTessellation:()=>[0,0]}},nr={marker:{type:u.SHORT,count:2,packPrecisionFactor:1,packAlternating:{count:4,packTessellation:({texXmax:s,texXmin:t,texYmax:e,texYmin:r})=>[[t,r],[s,r],[t,e],[s,e]]}}},or={type:u.UNSIGNED_SHORT,count:4,pack:({sprite:s})=>{const{rect:t,width:e,height:r}=s,i=t.x+b,n=t.y+b;return[i+1,n+1,i+e-1,n+r-1]}},ar={type:u.UNSIGNED_SHORT,count:4,packPrecisionFactor:4,pack:({animations:s,baseSize:t,referenceSize:e})=>[s.dataColumn,s.dataRow,t,e]},cr={type:u.UNSIGNED_SHORT,count:4,packPrecisionFactor:8,pack:({strokeWidth:s,pixelDimensions:t,baseSize:e,sprite:r,sizeRatio:i})=>{const n=Math.max(e*r.width/r.height,e),o=r.sdfDecodeCoeff*n*i;return[t[0],t[1],s,o]}},lr={type:u.BYTE,count:1,packTessellation:({angle:s})=>s};function Ps(s,t,e,r,i,n,o){$t=0;const a=(r-e)*n,c=i&&i.length,l=c?(i[0]-e)*n:a;let h,p,x,d,f,m=pe(t,e,r,0,l,n,!0);if(m&&m.next!==m.prev){if(c&&(m=$s(t,e,r,i,m,n)),a>80*n){h=x=t[0+e*n],p=d=t[1+e*n];for(let g=n;g<l;g+=n){const v=t[g+e*n],M=t[g+1+e*n];h=Math.min(h,v),p=Math.min(p,M),x=Math.max(x,v),d=Math.max(d,M)}f=Math.max(x-h,d-p),f=f!==0?1/f:0}J(m,s,n,h,p,f,o,0)}}function pe(s,t,e,r,i,n,o){let a;if(o===Ds(s,t,e,r,i,n)>0)for(let c=r;c<i;c+=n)a=Ut(c+t*n,s[c+t*n],s[c+1+t*n],a);else for(let c=i-n;c>=r;c-=n)a=Ut(c+t*n,s[c+t*n],s[c+1+t*n],a);return a&&B(a,a.next)&&(K(a),a=a.next),a}function j(s,t=s){if(!s)return s;let e,r=s;do if(e=!1,r.steiner||!B(r,r.next)&&k(r.prev,r,r.next)!==0)r=r.next;else{if(K(r),r=t=r.prev,r===r.next)break;e=!0}while(e||r!==t);return t}function J(s,t,e,r,i,n,o,a){if(!s)return;!a&&n&&(s=fe(s,r,i,n));let c=s;for(;s.prev!==s.next;){const l=s.prev,h=s.next;if(n?Ts(s,r,i,n):ws(s))t.push(l.index/e+o),t.push(s.index/e+o),t.push(h.index/e+o),K(s),s=h.next,c=h.next;else if((s=h)===c){a?a===1?J(s=Fs(s,t,e,o),t,e,r,i,n,o,2):a===2&&Ns(s,t,e,r,i,n,o):J(j(s),t,e,r,i,n,o,1);break}}}function ws(s){const t=s.prev,e=s,r=s.next;if(k(t,e,r)>=0)return!1;let i=s.next.next;const n=i;let o=0;for(;i!==s.prev&&(o===0||i!==n);){if(o++,U(t.x,t.y,e.x,e.y,r.x,r.y,i.x,i.y)&&k(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function Ts(s,t,e,r){const i=s.prev,n=s,o=s.next;if(k(i,n,o)>=0)return!1;const a=i.x<n.x?i.x<o.x?i.x:o.x:n.x<o.x?n.x:o.x,c=i.y<n.y?i.y<o.y?i.y:o.y:n.y<o.y?n.y:o.y,l=i.x>n.x?i.x>o.x?i.x:o.x:n.x>o.x?n.x:o.x,h=i.y>n.y?i.y>o.y?i.y:o.y:n.y>o.y?n.y:o.y,p=Tt(a,c,t,e,r),x=Tt(l,h,t,e,r);let d=s.prevZ,f=s.nextZ;for(;d&&d.z>=p&&f&&f.z<=x;){if(d!==s.prev&&d!==s.next&&U(i.x,i.y,n.x,n.y,o.x,o.y,d.x,d.y)&&k(d.prev,d,d.next)>=0||(d=d.prevZ,f!==s.prev&&f!==s.next&&U(i.x,i.y,n.x,n.y,o.x,o.y,f.x,f.y)&&k(f.prev,f,f.next)>=0))return!1;f=f.nextZ}for(;d&&d.z>=p;){if(d!==s.prev&&d!==s.next&&U(i.x,i.y,n.x,n.y,o.x,o.y,d.x,d.y)&&k(d.prev,d,d.next)>=0)return!1;d=d.prevZ}for(;f&&f.z<=x;){if(f!==s.prev&&f!==s.next&&U(i.x,i.y,n.x,n.y,o.x,o.y,f.x,f.y)&&k(f.prev,f,f.next)>=0)return!1;f=f.nextZ}return!0}function Ut(s,t,e,r){const i=V.create(s,t,e);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function K(s){s.next.prev=s.prev,s.prev.next=s.next,s.prevZ&&(s.prevZ.nextZ=s.nextZ),s.nextZ&&(s.nextZ.prevZ=s.prevZ)}function Ms(s){let t=s,e=s;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==s);return e}function $s(s,t,e,r,i,n){const o=new Array;for(let a=0,c=r.length;a<c;a++){const l=pe(s,t,e,r[a]*n,a<c-1?r[a+1]*n:e*n,n,!1);l===l.next&&(l.steiner=!0),o.push(Ms(l))}o.sort(Ls);for(const a of o)i=Es(a,i);return i}function Es(s,t){const e=As(s,t);if(!e)return t;const r=xe(e,s);return j(r,r.next),j(e,e.next)}function As(s,t){let e=t;const r=s.x,i=s.y;let n,o=-1/0;do{if(i<=e.y&&i>=e.next.y&&e.next.y!==e.y){const x=e.x+(i-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(x<=r&&x>o){if(o=x,x===r){if(i===e.y)return e;if(i===e.next.y)return e.next}n=e.x<e.next.x?e:e.next}}e=e.next}while(e!==t);if(!n)return null;if(r===o)return n.prev;const a=n,c=n.x,l=n.y;let h,p=1/0;for(e=n.next;e!==a;)r>=e.x&&e.x>=c&&r!==e.x&&U(i<l?r:o,i,c,l,i<l?o:r,i,e.x,e.y)&&(h=Math.abs(i-e.y)/(r-e.x),(h<p||h===p&&e.x>n.x)&&tt(e,s)&&(n=e,p=h)),e=e.next;return n}function fe(s,t,e,r){let i;for(;i!==s;i=i.next){if(i=i||s,i.z===null&&(i.z=Tt(i.x,i.y,t,e,r)),i.prev.next!==i||i.next.prev!==i)return i.prev.next=i,i.next.prev=i,fe(s,t,e,r);i.prevZ=i.prev,i.nextZ=i.next}return s.prevZ.nextZ=null,s.prevZ=null,zs(s)}function zs(s){let t,e=1;for(;;){let r,i=s;s=null,t=null;let n=0;for(;i;){n++,r=i;let o=0;for(;o<e&&r;o++)r=r.nextZ;let a=e;for(;o>0||a>0&&r;){let c;o===0?(c=r,r=r.nextZ,a--):a!==0&&r?i.z<=r.z?(c=i,i=i.nextZ,o--):(c=r,r=r.nextZ,a--):(c=i,i=i.nextZ,o--),t?t.nextZ=c:s=c,c.prevZ=t,t=c}i=r}if(t.nextZ=null,e*=2,n<2)return s}}function k(s,t,e){return(t.y-s.y)*(e.x-t.x)-(t.x-s.x)*(e.y-t.y)}function de(s,t,e,r){return!!(B(s,t)&&B(e,r)||B(s,r)&&B(e,t))||k(s,t,e)>0!=k(s,t,r)>0&&k(e,r,s)>0!=k(e,r,t)>0}function Is(s,t){let e=s;do{if(e.index!==s.index&&e.next.index!==s.index&&e.index!==t.index&&e.next.index!==t.index&&de(e,e.next,s,t))return!0;e=e.next}while(e!==s);return!1}function Ds(s,t,e,r,i,n){let o=0;for(let a=r,c=i-n;a<i;a+=n)o+=(s[c+t*n]-s[a+t*n])*(s[a+1+t*n]+s[c+1+t*n]),c=a;return o}function U(s,t,e,r,i,n,o,a){return(i-o)*(t-a)-(s-o)*(n-a)>=0&&(s-o)*(r-a)-(e-o)*(t-a)>=0&&(e-o)*(n-a)-(i-o)*(r-a)>=0}function tt(s,t){return k(s.prev,s,s.next)<0?k(s,t,s.next)>=0&&k(s,s.prev,t)>=0:k(s,t,s.prev)<0||k(s,s.next,t)<0}function Tt(s,t,e,r,i){return(s=1431655765&((s=858993459&((s=252645135&((s=16711935&((s=32767*(s-e)*i)|s<<8))|s<<4))|s<<2))|s<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-r)*i)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function B(s,t){return s.x===t.x&&s.y===t.y}function Ls(s,t){return s.x-t.x}function Fs(s,t,e,r){let i=s;do{const n=i.prev,o=i.next.next;!B(n,o)&&de(n,i,i.next,o)&&tt(n,o)&&tt(o,n)&&(t.push(n.index/e+r),t.push(i.index/e+r),t.push(o.index/e+r),K(i),K(i.next),i=s=o),i=i.next}while(i!==s);return i}function Ns(s,t,e,r,i,n,o){let a=s;do{let c=a.next.next;for(;c!==a.prev;){if(a.index!==c.index&&Os(a,c)){let l=xe(a,c);return a=j(a,a.next),l=j(l,l.next),J(a,t,e,r,i,n,o,0),void J(l,t,e,r,i,n,o,0)}c=c.next}a=a.next}while(a!==s)}function Os(s,t){return s.next.index!==t.index&&s.prev.index!==t.index&&!Is(s,t)&&tt(s,t)&&tt(t,s)&&Ys(s,t)}function Ys(s,t){let e=s,r=!1;const i=(s.x+t.x)/2,n=(s.y+t.y)/2;do e.y>n!=e.next.y>n&&e.next.y!==e.y&&i<(e.next.x-e.x)*(n-e.y)/(e.next.y-e.y)+e.x&&(r=!r),e=e.next;while(e!==s);return r}function xe(s,t){const e=V.create(s.index,s.x,s.y),r=V.create(t.index,t.x,t.y),i=s.next,n=t.prev;return s.next=t,t.prev=s,e.next=i,i.prev=e,r.next=e,e.prev=r,n.next=r,r.prev=n,r}class V{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(t,e,r){const i=$t<Mt.length?Mt[$t++]:new V;return i.index=t,i.x=e,i.y=r,i.prev=null,i.next=null,i.z=null,i.prevZ=null,i.nextZ=null,i.steiner=!1,i}}const Mt=[],Bs=8096;let $t=0;for(let s=0;s<Bs;s++)Mt.push(new V);const Cs=1e-5,Y=new Kt(0,0,0,1,0),Et=new Kt(0,0,0,1,0);function Ht(s,t,e){let r=0;for(let i=1;i<e;i++){const n=s[2*(t+i-1)],o=s[2*(t+i-1)+1];r+=(s[2*(t+i)]-n)*(s[2*(t+i)+1]+o)}return r}function Rs(s,t,e,r,i){let n=0;const o=2;for(let a=e;a<r;a+=3){const c=(s[a]-i)*o,l=(s[a+1]-i)*o,h=(s[a+2]-i)*o;n+=Math.abs((t[c]-t[h])*(t[l+1]-t[c+1])-(t[c]-t[l])*(t[h+1]-t[c+1]))}return n}function Gs(s,t){const{coords:e,lengths:r}=t,i=0,n=s;let o=0;for(let a=0;a<r.length;){let c=a,l=r[a],h=Ht(e,o,l);const p=[];for(;++c<r.length;){const m=r[c],g=Ht(e,o+l,m);if(!(g>0))break;h+=g,p.push(o+l),l+=m}const x=n.length;Ps(n,e,o,o+l,p,2,i);const d=Rs(n,e,x,n.length,i),f=Math.abs(h);if(Math.abs((d-f)/Math.max(1e-7,f))>Cs)return n.length=0,!1;a=c,o+=l}return!0}function Ws(s){const{coords:t,lengths:e}=s,{buffer:r}=je(t,e);return r}function Us(s,t,e){let r=0;for(let i=0;i<s.lengths.length;i++){const n=s.lengths[i];for(let o=0;o<n;o++){const a=s.coords[2*(o+r)],c=s.coords[2*(o+r)+1];if(a<t||a>e||c<t||c>e)return!0}r+=n}return!1}function me(s,t){if(s==null)return null;if(!Us(s,-128,lt+128))return s;Y.setPixelMargin(t),Y.reset(te.Polygon);let e=0;for(let o=0;o<s.lengths.length;o++){const a=s.lengths[o];let c=s.coords[2*(0+e)],l=s.coords[2*(0+e)+1];Y.moveTo(c,l);for(let h=1;h<a;h++)c=s.coords[2*(h+e)],l=s.coords[2*(h+e)+1],Y.lineTo(c,l);Y.close(),e+=a}const r=Y.result(!1);if(!r)return null;const i=[],n=[];for(const o of r){let a=0;for(const c of o)n.push(c.x),n.push(c.y),a++;i.push(a)}return new $e(i,n)}function Hs(s,t){Et.setPixelMargin(t);const e=Et,r=-t,i=lt+t;let n=[],o=!1;if(!s.nextPath())return null;let a=s.pathLength(),c=!0;for(;c;){s.seekPathStart();const l=[];if(!s.pathSize)return null;e.reset(te.LineString),s.nextPoint();let h=s.x,p=s.y;if(o)e.moveTo(h,p);else{if(h<r||h>i||p<r||p>i){o=!0;continue}l.push({x:h,y:p})}let x=!1;for(;s.nextPoint();)if(h=s.x,p=s.y,o)e.lineTo(h,p);else{if(h<r||h>i||p<r||p>i){x=!0;break}l.push({x:h,y:p})}if(x)o=!0;else{if(o){const d=e.resultWithStarts();if(d)for(const f of d)n.push({...f,pathLength:a})}else n.push({line:l,start:0,pathLength:a});c=s.nextPath(),a=c?s.pathLength():0,o=!1}}return n=n.filter(l=>l.line.length>1),n.length===0?null:n}Y.setExtent(lt),Et.setExtent(lt);let Xs=class{constructor(){this.extrusionOffsetX=0,this.extrusionOffsetY=0,this.normalX=0,this.normalY=0,this.directionX=0,this.directionY=0,this.distance=0,this.pathLength=0,this.distanceOffset=0,this.lineLength=0}};const D={createComputedParams:s=>s,optionalAttributes:{zoomRange:{type:u.SHORT,count:2,packPrecisionFactor:st,pack:({scaleInfo:s},{tileInfo:t})=>Z(s,t)}},attributes:{id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},bitset:{type:u.UNSIGNED_BYTE,count:1},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:s})=>_(s)},offset:{type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({extrusionOffsetX:s,extrusionOffsetY:t})=>[ot(s,16),ot(t,16)]},normal:{type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({normalX:s,normalY:t})=>[ot(s,16),ot(t,16)]},halfWidth:{type:u.HALF_FLOAT,count:1,pack:({width:s})=>y(.5*s)},referenceHalfWidth:{type:u.HALF_FLOAT,count:1,pack:({referenceWidth:s})=>y(.5*s)}}};let Vs=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0,this.distanceOffset=0}};const at=65535;let It=class extends G{constructor(t,e,r,i){super(t,e,r,i),this.vertexSpec=D,this._currentWrite=new Vs,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:at,textured:!1},this._tessParams=new Xs,this._initializeTessellator()}writeLineVertices(t,e,r){const i=this._getLines(e);i!=null&&this._writeVertices(t,r,i)}_initializeTessellator(){this._lineTessellator=new Je(this._writeTesselatedVertex.bind(this),this._writeTriangle.bind(this),!0)}_write(t,e,r){const i=r??I.fromFeatureSetReaderCIM(e);i&&this._writeGeometry(t,e,i)}_writeGeometry(t,e,r,i){t.recordStart(this.instanceId,this.attributeLayout,i),this.writeLineVertices(t,r,e),t.recordEnd()}_getLines(t){return Hs(t,ne(this.evaluatedMeshParams))}_writeVertices(t,e,r){const{_currentWrite:i,_tessellationOptions:n,evaluatedMeshParams:o}=this,{width:a,capType:c,joinType:l,miterLimit:h,hasSizeVV:p}=o,x=y(.5*a);n.halfWidth=x,n.capType=os(c),n.joinType=as(l),n.miterLimit=h;const d=!p;i.out=t,i.id=e.getDisplayId(),i.vertexCount=0,i.indexCount=0,i.vertexFrom=t.vertexCount(),i.vertexBounds=d&&x<Ee?0:1;for(const{line:f,start:m,pathLength:g}of r)n.initialDistance=m%at,i.pathLength=g,i.distanceOffset=Math.floor(m/at)*at,this._lineTessellator.tessellate(f,n,d)}_writeTesselatedVertex(t,e,r,i,n,o,a,c,l,h,p){const{out:x,id:d,vertexBounds:f,pathLength:m,distanceOffset:g}=this._currentWrite;return this.hasEffects&&x.recordBounds(t,e,f,f),this._tessParams.extrusionOffsetX=a,this._tessParams.extrusionOffsetY=c,this._tessParams.normalX=l,this._tessParams.normalY=h,this._tessParams.directionX=n,this._tessParams.directionY=o,this._tessParams.distance=p,this._tessParams.pathLength=m,this._tessParams.distanceOffset=g,this._writeVertex(x,d,t,e,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(t,e,r){const{out:i}=this._currentWrite;i.indexEnsureSize(3),i.indexWrite(t),i.indexWrite(e),i.indexWrite(r),this._currentWrite.indexCount+=3}};const Zs=100,qs=Ae("featurelayer-fast-triangulation-enabled");let Dt=class extends G{async loadDependencies(){await Promise.all([super.loadDependencies(),Ke()])}_write(t,e,r){const i=(r==null?void 0:r.asOptimized())??e.readGeometryForDisplay(),n=this._clip(i);n&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,e,n),t.recordEnd())}_clip(t){if(!t)return null;const e=this.hasEffects;return me(t,e?256:8)}_writeGeometry(t,e,r){const i=r.maxLength>Zs,n=[],o=this.createTesselationParams(e);if(!i&&qs&&Gs(n,r))return void(n.length&&this._writeVertices(t,e,r.coords,o,n));const a=Ws(r);this._writeVertices(t,e,a,o)}_writeVertices(t,e,r,i,n){const o=e.getDisplayId(),a=t.vertexCount(),c=this.hasEffects;let l=0;if(n)for(const h of n){const p=r[2*h],x=r[2*h+1];c&&t.recordBounds(p,x,0,0),this._writeVertex(t,o,p,x,i),l++}else for(let h=0;h<r.length;h+=2){const p=Math.round(r[h]),x=Math.round(r[h+1]);c&&t.recordBounds(p,x,0,0),this._writeVertex(t,o,p,x,i),l++}t.indexEnsureSize(l);for(let h=0;h<l;h++)t.indexWrite(h+a)}};const Qs={createComputedParams:s=>s,optionalAttributes:{},attributes:{id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1},pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:u.FLOAT,count:1,packTessellation:({inverseArea:s})=>s}}};let dr=class extends Dt{constructor(){super(...arguments),this.vertexSpec=Qs}createTesselationParams(t){return{inverseArea:1/t.readGeometryArea()}}};const et={createComputedParams:s=>s,optionalAttributes:{zoomRange:{type:u.SHORT,count:2,packPrecisionFactor:st,pack:({scaleInfo:s},{tileInfo:t})=>Z(s,t)}},attributes:{id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1},pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:s})=>_(s)}}};let ye=class extends Dt{constructor(){super(...arguments),this.vertexSpec=et}createTesselationParams(t){return null}};const R={createComputedParams:s=>s,optionalAttributes:et.optionalAttributes,attributes:{...et.attributes,tlbr:{count:4,type:u.UNSIGNED_SHORT,pack:({sprite:s})=>{const{rect:t,width:e,height:r}=s,i=t.x+b,n=t.y+b;return[i,n,i+e,n+r]}},inverseRasterizationScale:{count:1,type:u.BYTE,packPrecisionFactor:16,pack:({sprite:s})=>1/s.rasterizationScale}}};let js=class extends ye{constructor(){super(...arguments),this.vertexSpec=R}_write(t,e,r){var a;const i=(r==null?void 0:r.asOptimized())??e.readGeometryForDisplay(),n=this._clip(i);if(!n)return;const o=(a=this.evaluatedMeshParams.sprite)==null?void 0:a.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,o),this._writeGeometry(t,e,n),t.recordEnd()}};function ft(s){const{sprite:t,aspectRatio:e,scaleProportionally:r}=s,i=y(s.height),n=i>0?i:t.height;let o=i*e;return o<=0?o=t.width:r&&(o*=t.width/t.height),{width:o,height:n}}function ge(s){const{applyRandomOffset:t,sampleAlphaOnly:e}=s;return q([[He,t],[ie,e]])}const _e={createComputedParams:s=>s,optionalAttributes:R.optionalAttributes,attributes:{...R.attributes,bitset:{count:1,type:u.UNSIGNED_BYTE,pack:ge},width:{count:1,type:u.HALF_FLOAT,pack:s=>ft(s).width},height:{count:1,type:u.HALF_FLOAT,pack:s=>ft(s).height},offset:{count:2,type:u.HALF_FLOAT,pack:({offsetX:s,offsetY:t})=>[y(s),-y(t)]},scale:{count:2,type:u.UNSIGNED_BYTE,packPrecisionFactor:16,pack:({scaleX:s,scaleY:t})=>[s,t]},angle:{count:1,type:u.UNSIGNED_BYTE,pack:({angle:s})=>ze(s)}}};let gr=class extends js{constructor(){super(...arguments),this.vertexSpec=_e}};const ke={createComputedParams:s=>s,optionalAttributes:D.optionalAttributes,attributes:{...D.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:s=>0},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:s})=>_(s)}}},Lt={createComputedParams:s=>s,optionalAttributes:D.optionalAttributes,attributes:{...D.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:s=>q([[re,!0],[Xe,s.outlineUsesColorVV]])},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:s})=>_(s)}}};let Ft=class extends It{constructor(){super(...arguments),this.vertexSpec=Lt}},Se=class extends ye{constructor(t,e,r,i){super(t,e,r,i),this.vertexSpec=ke,this._lineMeshWriter=this._createOutlineWriter(t,e,r,i)}_createOutlineWriter(t,e,r,i){return new Ft(t,e,r,i)}_write(t,e){const r=this.evaluatedMeshParams.effects,i=this.evaluatedMeshParams.outlineEffects;if(r!=null&&r.length||i!=null&&i.length){if(r!=null&&r.length){const n=this.getEffectCursor(t,e,r);if(n){let o;for(;o=n==null?void 0:n.next();)o.invertY(),this._writeFill(t,e,o)}}else this._writeFill(t,e);if(i!=null&&i.length){const n=this.getEffectCursor(t,e,i);if(n){let o;for(;o=n==null?void 0:n.next();)o.invertY(),this._writeOutline(t,e,o)}}else this._writeOutline(t,e)}else this._writeSimpleOutlineFill(t,e)}_writeSimpleOutlineFill(t,e){const r=e.readGeometryForDisplay(),i=this._clip(r);i&&(this._writeGeometry(t,e,i),this._lineMeshWriter.writeLineVertices(t,I.fromOptimizedCIM(i,"esriGeometryPolyline"),e))}_writeFill(t,e,r){const i=(r==null?void 0:r.asOptimized())??e.readGeometryForDisplay(),n=this._clip(i);n&&this._writeGeometry(t,e,n)}_writeOutline(t,e,r){const i=(r==null?void 0:r.asOptimized())??e.readGeometryForDisplay(),n=this._clip(i);n&&this._lineMeshWriter.writeLineVertices(t,I.fromOptimizedCIM(n,"esriGeometryPolyline"),e)}_clip(t){return t?me(t,ne(this.evaluatedMeshParams)):null}get effectInfos(){var t,e;return[...((t=this._evaluator.inputMeshParams.effects)==null?void 0:t.effectInfos)??[],...((e=this._evaluator.inputMeshParams.outlineEffects)==null?void 0:e.effectInfos)??[]]}write(t,e,r,i,n){this.ensurePacked(e,r,i),t.recordStart(this.instanceId,this.attributeLayout),this._write(t,r),t.recordEnd()}ensurePacked(t,e,r){super.ensurePacked(t,e,r),this._lineMeshWriter.ensurePacked(t,e,r)}enqueueRequest(t,e,r){super.enqueueRequest(t,e,r),this._lineMeshWriter.enqueueRequest(t,e,r)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}get hasEffects(){return!!this.evaluatedMeshParams.outlineEffects}};const dt=_e,Js=Lt,Ks={createComputedParams:s=>s,optionalAttributes:dt.optionalAttributes,attributes:{...dt.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:s=>ge(s)},aux1:{count:1,type:u.HALF_FLOAT,pack:s=>ft(s).width},aux2:{count:1,type:u.HALF_FLOAT,pack:s=>ft(s).height},aux3:{count:2,type:u.HALF_FLOAT,pack:({offsetX:s,offsetY:t})=>[y(s),y(t)]},aux4:{count:2,type:u.UNSIGNED_BYTE,pack:({scaleX:s,scaleY:t})=>[s*pt,t*pt]}}},ti={createComputedParams:s=>s,optionalAttributes:dt.optionalAttributes,attributes:{...dt.attributes,color:Js.attributes.color,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:s=>q([[re,!0]])},aux1:{count:1,type:u.HALF_FLOAT,pack:s=>y(.5*s.width)},aux2:{count:1,type:u.HALF_FLOAT,pack:s=>y(.5*s.referenceWidth)},aux3:{count:2,type:u.HALF_FLOAT,packTessellation:({extrusionOffsetX:s,extrusionOffsetY:t})=>[s,t]},aux4:{count:2,type:u.UNSIGNED_BYTE,packTessellation:({normalX:s,normalY:t})=>[s*pt+Gt,t*pt+Gt]}}};let ei=class extends Ft{constructor(){super(...arguments),this.vertexSpec=ti}};class vr extends Se{constructor(){super(...arguments),this.vertexSpec=Ks}_createOutlineWriter(t,e,r,i){return new ei(t,e,r,i)}write(t,e,r,i,n){var a;this.ensurePacked(e,r,i);const o=(a=this.evaluatedMeshParams.sprite)==null?void 0:a.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,o),this._write(t,r),t.recordEnd()}ensurePacked(t,e,r){super.ensurePacked(t,e,r),this._lineMeshWriter.ensurePacked(t,e,r)}enqueueRequest(t,e,r){super.enqueueRequest(t,e,r),this._lineMeshWriter.enqueueRequest(t,e,r)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const si=()=>Jt.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.fill.GradientSizeHelper");let ii=class{constructor(t,e){this._size=t,this._sizeUnits=e,this._relativeSize=null}get relativeSize(){return this._relativeSize??(this._relativeSize=this.calculateRelativeSize()),this._relativeSize}calculateRelativeSize(){if(this._sizeUnits===ut.Relative){const t=Math.min(this._size/100,1);return[t,t]}return this.calculateRelativeSizeFromAbsolute()}},Nt=class extends ii{constructor(t,e,r,i){super(e,r),this.rotationMatrix00=1,this.rotationMatrix01=0,this.rotationMatrix10=0,this.rotationMatrix11=1,this.bounds={xmin:1/0,ymin:1/0,xmax:-1/0,ymax:-1/0},this.rotationMatrix00=Math.cos(i),this.rotationMatrix01=-Math.sin(i),this.rotationMatrix10=-this.rotationMatrix01,this.rotationMatrix11=this.rotationMatrix00;const{bounds:n,rotationMatrix00:o,rotationMatrix01:a,rotationMatrix10:c,rotationMatrix11:l}=this;t.forEachVertex((h,p)=>{const x=h*o+p*a,d=h*c+p*l;n.xmin=Math.min(n.xmin,x),n.ymin=Math.min(n.ymin,d),n.xmax=Math.max(n.xmax,x),n.ymax=Math.max(n.ymax,d)}),this.center=[(n.xmin+n.xmax)/2,(n.ymin+n.ymax)/2]}},ri=class extends Nt{constructor(t,e,r,i){super(t,e,r,i),this.method="linear"}getRelativePosition(t,e){const{rotationMatrix00:r,rotationMatrix01:i,bounds:n}=this,{xmin:o,xmax:a}=n;return[(t*r+e*i-o)/(a-o),0]}calculateRelativeSizeFromAbsolute(){const{_size:t,bounds:e}=this,{xmin:r,xmax:i}=e;return[y(t)/(i-r),0]}};class ni extends Nt{constructor(t,e,r,i){super(t,e,r,i),this.method="rectangular"}getRelativePosition(t,e){const{bounds:r,center:i,rotationMatrix00:n,rotationMatrix01:o,rotationMatrix10:a,rotationMatrix11:c}=this,l=t*a+e*c,h=t*n+e*o-i[0],p=l-i[1];return[h*(2/(r.xmax-r.xmin)),-p*(2/(r.ymax-r.ymin))]}calculateRelativeSizeFromAbsolute(){const{_size:t,bounds:e}=this,{xmin:r,ymin:i,xmax:n,ymax:o}=e;return[y(2*t)/(n-r),y(2*t)/(o-i)]}}class oi extends Nt{constructor(t,e,r){super(t,e,r,0),this.method="circular";const{xmin:i,xmax:n,ymin:o,ymax:a}=this.bounds,c=n-i,l=a-o;this.radius=Math.sqrt(c*c+l*l)/2}getRelativePosition(t,e){const{center:r,radius:i}=this;return[(t-r[0])/i,-((e-r[1])/i)]}calculateRelativeSizeFromAbsolute(){const{_size:t}=this;return[y(t)/this.radius,0]}}function ai(s,t){if(s==null)return null;const e=Ie(t.angle),r=t.gradientSize,i=t.gradientSizeUnits;switch(t.gradientMethod.toLowerCase()){case"linear":return new ri(s,r,i,e);case"rectangular":return new ni(s,r,i,e);case"circular":return new oi(s,r,i);default:return si().errorOnce(`Gradient fill method "${t.gradientMethod}" currently unsupported.`),null}}const ci={createComputedParams:s=>s,optionalAttributes:et.optionalAttributes,attributes:{...et.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:({gradientSizeUnits:s,gradientType:t})=>{let e=0;return s===ut.Absolute&&(e|=w(Rt.isAbsolute)),t.toLowerCase()==="discrete"&&(e|=w(Rt.isDiscrete)),e}},tlbr:{count:4,type:u.UNSIGNED_SHORT,pack:({sprite:s})=>{const{rect:t,width:e,height:r}=s,i=t.x+b+ht,n=t.y+b;return[i,n,i+e-2*ht,n+r]}},relativePosition:{count:2,type:u.HALF_FLOAT,packTessellation:({gradientStats:s},t,e,r)=>(s==null?void 0:s.getRelativePosition(e,r))??[0,0]},relativeGradientSize:{count:2,type:u.HALF_FLOAT,packTessellation:({gradientStats:s})=>(s==null?void 0:s.relativeSize)??[1,1]},gradientMethod:{count:1,type:u.UNSIGNED_BYTE,pack:({gradientMethod:s})=>{switch(s.toLowerCase()){case"rectangular":return kt.rectangular;case"circular":return kt.circular;default:return kt.linear}}}}};let Mr=class extends Dt{constructor(){super(...arguments),this.vertexSpec=ci}get _preventEffectClipping(){return!0}createTesselationParams(t){return{gradientStats:ai(this._unclippedGeometry,this.evaluatedMeshParams)}}_write(t,e,r){var a;const i=(r==null?void 0:r.asOptimized())??e.readGeometryForDisplay();this._unclippedGeometry=i;const n=this._clip(i);if(!n)return void(this._unclippedGeometry=null);const o=(a=this.evaluatedMeshParams.sprite)==null?void 0:a.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,o),this._writeGeometry(t,e,n),this._unclippedGeometry=null,t.recordEnd()}};const li={optionalAttributes:R.optionalAttributes,createComputedParams:s=>s,attributes:{...R.attributes,...ke.attributes}},ui={optionalAttributes:R.optionalAttributes,createComputedParams:s=>s,attributes:{...R.attributes,...Lt.attributes}};class hi extends Ft{constructor(){super(...arguments),this.vertexSpec=ui}}let Er=class extends Se{constructor(){super(...arguments),this.vertexSpec=li}_createOutlineWriter(t,e,r,i){return new hi(t,e,r,i)}write(t,e,r,i,n){var a;this.ensurePacked(e,r,i);const o=(a=this.evaluatedMeshParams.sprite)==null?void 0:a.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,o),this._write(t,r),t.recordEnd()}ensurePacked(t,e,r){super.ensurePacked(t,e,r),this._lineMeshWriter.ensurePacked(t,e,r)}enqueueRequest(t,e,r){super.enqueueRequest(t,e,r),this._lineMeshWriter.enqueueRequest(t,e,r)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const pi={createComputedParams:s=>s,optionalAttributes:{},attributes:{pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1},offset:{type:u.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};let zr=class extends G{constructor(){super(...arguments),this.vertexSpec=pi}_write(t,e){t.recordStart(this.instanceId,this.attributeLayout);const r=e.getDisplayId();if(e.geometryType==="esriGeometryPoint"){const i=e.readXForDisplay(),n=e.readYForDisplay();this._writeQuad(t,r,i,n)}else if(e.geometryType==="esriGeometryMultipoint"){const i=e.readGeometryForDisplay();i==null||i.forEachVertex((n,o)=>{n>=0&&n<=512&&o>=0&&o<=512&&this._writeQuad(t,r,n,o)})}t.recordEnd()}_writeQuad(t,e,r,i){const n=t.vertexCount();this._writeVertex(t,e,r,i),t.indexWrite(n+0),t.indexWrite(n+1),t.indexWrite(n+2),t.indexWrite(n+1),t.indexWrite(n+3),t.indexWrite(n+2)}};const Xt=96;class fi{constructor(t){const{offsetX:e,offsetY:r,postAngle:i,fontSize:n,haloSize:o,outlineSize:a,scaleFactor:c,transforms:l}=t;if(this.offsetX=e,this.offsetY=r,this.postAngle=i,this.fontSize=Math.min(n,Xt),this.haloSize=o??0,this.outlineSize=a??0,this.transforms=l,l&&l.infos.length>1){const h=ee(n,i,!1,e,r,l,!1);this.fontSize=Math.min(h.size,Xt);const p=h.size/n;this.haloSize*=p,this.outlineSize*=p,this.postAngle=h.rotation,this.offsetX=h.offsetX,this.offsetY=h.offsetY}c&&(this.fontSize*=c,this.offsetX*=c,this.offsetY*=c)}}const di=28,F=[4,4],ct=[16,4],xi={topLeft:ct,topRight:ct,bottomLeft:ct,bottomRight:ct},xt=[4,2],T=[4,6],Vt={topLeft:xt,topRight:xt,bottomLeft:T,bottomRight:T},Zt={topLeft:xt,topRight:T,bottomLeft:xt,bottomRight:T},mi={topLeft:T,topRight:T,bottomLeft:F,bottomRight:F},yi={topLeft:F,topRight:F,bottomLeft:T,bottomRight:T},gi={topLeft:T,topRight:F,bottomLeft:T,bottomRight:F},_i={topLeft:F,topRight:T,bottomLeft:F,bottomRight:T},ki={createComputedParams:s=>s,optionalAttributes:{zoomRange:{type:u.UNSIGNED_SHORT,count:2,packPrecisionFactor:st,packTessellation:({minZoom:s,maxZoom:t})=>[s||0,t||di]},clipAngle:{type:u.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:s})=>Si(s||0)},referenceSymbol:{type:u.BYTE,count:4,packPrecisionFactor:1,packTessellation:(s,t)=>{const e=s.isLineLabel||!s.referenceBounds,r=Oe(e?"center":t.horizontalAlignment),i=Ye(e?"middle":t.verticalAlignment),{offsetX:n,offsetY:o,size:a}=e?{offsetX:0,offsetY:0,size:0}:s.referenceBounds;return[y(n),-y(o),Math.round(y(a)),r+1<<2|i+1]}},visibility:{type:u.FLOAT,count:1,otherSource:!0}},attributes:{pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:s,mapAligned:t})=>q([[Ve,s],[Ze,!!t]])},offset:{type:u.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:s})=>{const{bottomLeft:t,bottomRight:e,topLeft:r,topRight:i}=s;return[r,i,t,e]}}},textureUV:{type:u.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:s})=>{const{bottomLeft:t,bottomRight:e,topLeft:r,topRight:i}=s;return[r,i,t,e]}}},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:s})=>s},fontAndReferenceSize:{type:u.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({fontSize:s},{referenceSize:t})=>[Math.round(y(s)),Math.round(y(t??s))]},outlineColor:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:s})=>_(s)},haloColor:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:s})=>_(s)},outlineAndHaloSize:{type:u.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({outlineSize:s,haloSize:t})=>[Math.round(y(s)),Math.round(y(t))]}}};class Dr extends G{constructor(){super(...arguments),this.vertexSpec=ki,this._textMeshParamsPropsInitialized=!1}ensurePacked(t,e,r){super.ensurePacked(t,e,r),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new fi(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(t,e,r){const i=this._getShaping();if(!i)return;const n=e.getDisplayId();if(this.evaluatedMeshParams.placement!=null)return this._writePlacedTextMarkers(t,e,i,r);if(r!=null&&r.nextPath())return r.nextPoint(),this._writeGlyphs(t,n,r.x,r.y,i,0);if(e.geometryType==="esriGeometryPolygon"){const c=e.readCentroidForDisplay();if(!c)return;const[l,h]=c.coords;return this._writeGlyphs(t,n,l,h,i,0)}if(e.geometryType==="esriGeometryMultipoint"){const c=e.readGeometryForDisplay();return void(c==null?void 0:c.forEachVertex((l,h)=>this._writeGlyphs(t,n,l,h,i,0)))}const o=e.readXForDisplay(),a=e.readYForDisplay();return this._writeGlyphs(t,n,o,a,i,0)}_writePlacedTextMarkers(t,e,r,i){const n=i??I.fromFeatureSetReaderCIM(e);if(!n)return;const o=-1,a=oe.getPlacement(n,o,this.evaluatedMeshParams.placement,y(1),t.id,zt());if(!a)return;const c=e.getDisplayId();let l=a.next();for(;l!=null;){const h=l.tx,p=-l.ty,x=-l.getAngle();this._writeGlyphs(t,c,h,p,r,x),l=a.next()}}_getShaping(t){var l;const e=this._textMeshTransformProps,r=this.evaluatedMeshParams;if(!((l=r.glyphs)!=null&&l.glyphs.length))return null;const i=y(e.fontSize),n=y(e.offsetX),o=y(e.offsetY),a=Ct(y(r.lineWidth),Le,De),c=Fe*Ct(r.lineHeightRatio,.25,4);return Ne(r.glyphs,{scale:i/Be,angle:e.postAngle,xOffset:n,yOffset:o,horizontalAlignment:r.horizontalAlignment,verticalAlignment:t||r.verticalAlignment,maxLineWidth:a,lineHeight:c,decoration:r.decoration,borderLineSizePx:y(r.boxBorderLineSize),hasBackground:!!r.boxBackgroundColor,useCIMAngleBehavior:r.useCIMAngleBehavior})}_writeGlyphs(t,e,r,i,n,o,a,c,l=!0){const h=this.evaluatedMeshParams,p=this._textMeshTransformProps,x=y(p.fontSize),d=p.haloSize,f=p.outlineSize,m=y(p.offsetX),g=y(p.offsetY),[v,M]=Z(h.scaleInfo,this.getTileInfo());o!==0&&n.setRotation(o);const A=n.bounds,z=r+A.x+m,N=i+A.y-g,L=2*(h.minPixelBuffer?h.minPixelBuffer/x:1),$=Math.max(A.width,A.height)*L;n.textBox&&(t.recordStart(this.instanceId,this.attributeLayout,n.glyphs[0].textureBinding),l&&t.recordBounds(z,N,$,$),this._writeTextBox(t,e,r,i,n.textBox,a,c),t.recordEnd());for(const O of n.glyphs){t.recordStart(this.instanceId,this.attributeLayout,O.textureBinding),l&&t.recordBounds(z,N,$,$);const{texcoords:W,offsets:be}=O;this._writeQuad(t,e,r,i,{texcoords:W,offsets:be,fontSize:x,haloSize:d,outlineSize:f,color:_(h.color),isBackground:!1,referenceBounds:a,minZoom:v,maxZoom:M,...c}),t.recordEnd()}o!==0&&n.setRotation(-o)}_writeTextBox(t,e,r,i,n,o,a){const c=this.evaluatedMeshParams,{fontSize:l,haloSize:h,outlineSize:p}=this._textMeshTransformProps,{boxBackgroundColor:x,boxBorderLineColor:d}=c,f={isBackground:!0,fontSize:l,haloSize:h,outlineSize:p,referenceBounds:o,...a};x&&(this._writeQuad(t,e,r,i,{texcoords:xi,offsets:n.main,color:_(x),...f}),d||(this._writeQuad(t,e,r,i,{texcoords:mi,offsets:n.top,color:_(x),...f}),this._writeQuad(t,e,r,i,{texcoords:yi,offsets:n.bot,color:_(x),...f}),this._writeQuad(t,e,r,i,{texcoords:gi,offsets:n.left,color:_(x),...f}),this._writeQuad(t,e,r,i,{texcoords:_i,offsets:n.right,color:_(x),...f}))),d&&(this._writeQuad(t,e,r,i,{texcoords:Vt,offsets:n.top,color:_(d),...f}),this._writeQuad(t,e,r,i,{texcoords:Vt,offsets:n.bot,color:_(d),...f}),this._writeQuad(t,e,r,i,{texcoords:Zt,offsets:n.left,color:_(d),...f}),this._writeQuad(t,e,r,i,{texcoords:Zt,offsets:n.right,color:_(d),...f}))}_writeQuad(t,e,r,i,n){const o=t.vertexCount();this._writeVertex(t,e,r,i,n),t.indexWrite(o+0),t.indexWrite(o+1),t.indexWrite(o+2),t.indexWrite(o+1),t.indexWrite(o+3),t.indexWrite(o+2)}}const Si=s=>Math.round(s*(254/360)),bi={createComputedParams:s=>s,optionalAttributes:D.optionalAttributes,attributes:{...D.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:({gradientMethod:s,gradientSizeUnits:t,gradientType:e})=>q([[St.isAlongLine,s.toLowerCase()==="alongline"],[St.isAbsoluteSize,t===ut.Absolute],[St.isDiscrete,e.toLowerCase()==="discrete"]])},tlbr:{type:u.UNSIGNED_SHORT,count:4,pack:({sprite:s})=>{const{rect:t,width:e,height:r}=s,i=t.x+b+ht,n=t.y+b;return[i,n,i+e-2*ht,n+r]}},accumulatedDistance:{type:u.HALF_FLOAT,count:1,packTessellation:({distance:s,pathLength:t,distanceOffset:e})=>(e+s)/t},gradientSize:{type:u.HALF_FLOAT,count:1,pack:({gradientSize:s,gradientSizeUnits:t})=>t===ut.Relative?s/100:y(s)},totalLength:{type:u.HALF_FLOAT,count:1,packTessellation:({pathLength:s})=>s},segmentDirection:{type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:s,directionY:t})=>[s,t]}}};let Lr=class extends It{get _preventEffectClipping(){return!0}constructor(t,e,r,i){super(t,e,r,i),this.vertexSpec=bi,this._tessellationOptions.textured=!0}_write(t,e,r){const i=r??I.fromFeatureSetReaderCIM(e);if(!i)return;const{sprite:n}=this.evaluatedMeshParams;this._writeGeometry(t,e,i,n==null?void 0:n.textureBinding)}};const vi={createComputedParams:s=>s,optionalAttributes:D.optionalAttributes,attributes:{...D.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:({shouldSampleAlphaOnly:s,shouldScaleDash:t,isSDF:e})=>q([[ie,s],[qe,t],[Qe,e]])},tlbr:{type:u.UNSIGNED_SHORT,count:4,pack:({sprite:s})=>{const{rect:t,width:e,height:r}=s,i=t.x+b,n=t.y+b;return[i,n,i+e,n+r]}},accumulatedDistance:{type:u.UNSIGNED_SHORT,count:1,packTessellation:({distance:s})=>s},segmentDirection:{type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:s,directionY:t})=>[s,t]},offsetAlongLine:{type:u.HALF_FLOAT,count:1,pack:({offsetAlongLine:s})=>y(s)},capType:{type:u.UNSIGNED_BYTE,count:1,pack:({capType:s})=>{switch(s){case H.Butt:case"butt":return 0;case H.Square:case"square":return 1;case H.Round:case"round":return 2;default:return 0}}}}};class Nr extends It{constructor(t,e,r,i){super(t,e,r,i),this.vertexSpec=vi,this._tessellationOptions.textured=!0}_write(t,e,r){const i=r??I.fromFeatureSetReaderCIM(e);if(!i)return;const{sprite:n}=this.evaluatedMeshParams;this._writeGeometry(t,e,i,n==null?void 0:n.textureBinding)}}let Pi=class At{static from(t){return"width"in t?this.fromSimpleMeshParams(t):this.fromComplexMeshParams(t)}static fromSimpleMeshParams(t){const e=new At(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects),{type:r,width:i,height:n,angle:o,alignment:a,outlineSize:c,referenceSize:l,sprite:h,overrideOutlineColor:p}=t;return e.rawWidth=y(i),e.rawHeight=y(n),e.angle=o,e.alignment=a,e.outlineSize=y(c),e.referenceSize=y(l),e.overrideOutlineColor=p,e.offsetX=y(t.offsetX),e.offsetY=y(t.offsetY),r!=="simple"||h.sdf||(e.rawWidth=h.width,e.rawHeight=h.height),e._computeSize(t,!1),e}static fromComplexMeshParams(t){const e=new At(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects);let{alignment:r,transforms:i,size:n,scaleX:o,anchorX:a,anchorY:c,angle:l,colorLocked:h,frameHeight:p,widthRatio:x,offsetX:d,offsetY:f,outlineSize:m,referenceSize:g,scaleFactor:v,sizeRatio:M,isAbsoluteAnchorPoint:A,rotateClockwise:z,scaleSymbolsProportionally:N,sprite:L}=t;if(i&&i.infos.length>0){const W=ee(n,l,z,d,f,i);n=W.size,l=W.rotation,d=W.offsetX,f=W.offsetY,z=!1}v&&(n*=v,d*=v,f*=v);const $=o*(L.width/L.height);e.alignment=r,e.rawHeight=y(n),e.rawWidth=e.rawHeight*$,e.referenceSize=y(g),e.sizeRatio=M,e.sdfDecodeCoeff=(L.sdfDecodeCoeff??1)*M,e.angle=l,e.rotateClockwise=z,e.anchorX=a,e.anchorY=c,e.offsetX=y(d),e.offsetY=y(f),A&&n&&(L.sdf?e.anchorX=a/(n*x):e.anchorX=a/(n*$),e.anchorY=c/n);const O=N&&p?n/p:1;return e.outlineSize=m===0||isNaN(m)?0:y(m)*O,e.scaleSymbolsProportionally=N,e.colorLocked=h,e._computeSize(t,!0),e}constructor(t,e,r,i,n,o,a){this.sprite=t,this.color=e,this.outlineColor=r,this.minPixelBuffer=i,this.placement=n,this.scaleInfo=o,this.effects=a,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=se.SCREEN,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(t,e){const{sprite:r,hasSizeVV:i}=t,n=!!r.sdf,o=r.sdfPaddingRatio??.5,{rawWidth:a,rawHeight:c,sizeRatio:l,outlineSize:h}=this,p=r.rect;let x=a*l,d=c*l,f=0,m=0;if(n){const z=1/(1-o);if(x*=z,d*=z,i)this.computedWidth=x,this.computedHeight=d;else{const N=e&&a>c?x:a,L=c,$=h+2*1;this.computedWidth=Math.min(N+$,x),this.computedHeight=Math.min(L+$,d);const O=Math.max(r.width,r.height)/Math.max(x,d);f=(this.computedWidth-x)*O,m=(this.computedHeight-d)*O}}else this.computedWidth=x*(p.width/r.width),this.computedHeight=d*(p.height/r.height),f=2*b,m=2*b;const g=p.x+b-f/2,v=p.y+b-m/2,M=g+r.width+f,A=v+r.height+m;this.texXmin=qt(g),this.texYmin=qt(v),this.texXmax=Qt(M),this.texYmax=Qt(A),this.computedWidth*=(this.texXmax-this.texXmin)/(M-g),this.computedHeight*=(this.texYmax-this.texYmin)/(A-v),this.anchorX*=x/this.computedWidth,this.anchorY*=d/this.computedHeight}};function qt(s,t=1e-7){const e=Math.ceil(s);return e-s<t?e:Math.floor(s)}function Qt(s,t=1e-7){const e=Math.floor(s);return s-e<t?e:Math.ceil(s)}const wi=3.14159265359/180,Ti=128/Math.PI;function Mi(s,t){return s%=t,Math.abs(s>=0?s:s+t)}function $i(s){return Mi(s*Ti,256)}function Ei(s,t,e,r,i=!1){const n=Re(),o=i?1:-1;return Ge(n),(t||e)&&We(n,n,[t,-e]),r&&Ue(n,n,o*wi*-r),n}const Ai={createComputedParams:s=>Pi.from(s),optionalAttributes:{zoomRange:{type:u.SHORT,count:2,packPrecisionFactor:st,pack:({scaleInfo:s},{tileInfo:t})=>Z(s,t)}},attributes:{pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1,pack:({sprite:s,alignment:t,scaleSymbolsProportionally:e,overrideOutlineColor:r,colorLocked:i})=>{let n=0;return s.sdf&&(n|=w(E.bitset.isSDF)),t===se.MAP&&(n|=w(E.bitset.isMapAligned)),e&&(n|=w(E.bitset.scaleSymbolsProportionally)),r&&(n|=w(E.bitset.overrideOutlineColor)),i&&(n|=w(E.bitset.colorLocked)),n}},offset:{type:u.HALF_FLOAT,count:2,packAlternating:{count:4,pack:({angle:s,computedWidth:t,computedHeight:e,anchorX:r,anchorY:i,offsetX:n,offsetY:o,rotateClockwise:a})=>{const c=Ei(0,n,o,-s,a),l=-(.5+r)*t,h=-(.5-i)*e,p=[l,h],x=[l+t,h],d=[l,h+e],f=[l+t,h+e];return nt(p,p,c),nt(x,x,c),nt(d,d,c),nt(f,f,c),[p,x,d,f]}}},textureUV:{type:u.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:s,texXmin:t,texYmax:e,texYmin:r})=>[[t,r],[s,r],[t,e],[s,e]]}},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:s})=>_(s)},outlineColor:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:s})=>_(s)},sizing:{type:u.UNSIGNED_BYTE,count:4,pack:({rawWidth:s,rawHeight:t,outlineSize:e,referenceSize:r})=>{const i=Math.max(s,t);return[bt(i,128),bt(e,128),bt(r,128),0]}},placementAngle:{type:u.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:s})=>$i(s)},sdfDecodeCoeff:{type:u.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:s})=>s}}};class Or extends G{constructor(){super(...arguments),this.vertexSpec=Ai}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(t,e,r){var d;const i=(d=this.evaluatedMeshParams.sprite)==null?void 0:d.textureBinding,n=e.getDisplayId();t.recordStart(this.instanceId,this.attributeLayout,i);const o=this.evaluatedMeshParams.minPixelBuffer,a=Math.max(this.evaluatedMeshParams.computedWidth,o),c=Math.max(this.evaluatedMeshParams.computedHeight,o),l=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,h=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,p=this.evaluatedMeshParams.offsetX+l,x=-this.evaluatedMeshParams.offsetY+h;if(this.evaluatedMeshParams.placement!=null){let f=null;if(r!=null){const m=Math.max(this.evaluatedMeshParams.computedWidth,this.evaluatedMeshParams.computedHeight);if(f=Ce(r,2*m,!1),f===null)return}this._writePlacedMarkers(t,e,f,a,c)}else if(r!=null&&r.nextPath()){r.nextPoint();const f=r.x,m=r.y;t.recordBounds(f+p,m+x,a,c),this._writeQuad(t,n,f,m)}else if(e.geometryType==="esriGeometryPolygon"){const f=e.readCentroidForDisplay();if(!f)return;const[m,g]=f.coords;t.recordBounds(m+p,g+x,a,c),this._writeQuad(t,n,m,g)}else if(e.geometryType==="esriGeometryPoint"){const f=e.readXForDisplay(),m=e.readYForDisplay();t.recordBounds(f+p,m+x,a,c),this._writeQuad(t,n,f,m)}else{const f=e.readGeometryForDisplay();f==null||f.forEachVertex((m,g)=>{t.recordBounds(m+p,g+x,a,c),Math.abs(m)>rt||Math.abs(g)>rt||this._writeQuad(t,n,m,g)})}t.recordEnd()}_writePlacedMarkers(t,e,r,i,n){const o=r??I.fromFeatureSetReaderCIM(e);if(!o)return;const a=-1,c=oe.getPlacement(o,a,this.evaluatedMeshParams.placement,y(1),t.id,zt());if(!c)return;const l=e.getDisplayId();let h=c.next();const p=this.evaluatedMeshParams.offsetX,x=-this.evaluatedMeshParams.offsetY;for(;h!=null;){const d=h.tx,f=-h.ty;if(Math.abs(d)>rt||Math.abs(f)>rt){h=c.next();continue}const m=-h.getAngle();t.recordBounds(d+p,f+x,i,n),this._writeQuad(t,l,d,f,m),h=c.next()}}_writeQuad(t,e,r,i,n){const o=t.vertexCount(),a=n==null?null:{placementAngle:n};this._writeVertex(t,e,r,i,a),t.indexWrite(o+0),t.indexWrite(o+1),t.indexWrite(o+2),t.indexWrite(o+1),t.indexWrite(o+3),t.indexWrite(o+2)}}const zi={createComputedParams:s=>s,optionalAttributes:{},attributes:{pos:{type:u.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1,pack:s=>0},offset:{type:u.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:s})=>{const t=y(s),e=-t/2,r=-t/2;return[[e,r],[e+t,r],[e,r+t],[e+t,r+t]]}}},texCoords:{type:u.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:u.UNSIGNED_BYTE,count:2,pack:({size:s})=>[s,s]},referenceSize:{type:u.UNSIGNED_BYTE,count:1,pack:({size:s})=>y(s)},zoomRange:{type:u.UNSIGNED_BYTE,count:2,pack:({scaleInfo:s},{tileInfo:t})=>Z(s,t)}}};class Yr extends G{constructor(){super(...arguments),this.vertexSpec=zi}_write(t,e){const r=e.getDisplayId(),i=this.evaluatedMeshParams.minPixelBuffer,n=Math.max(y(this.evaluatedMeshParams.size),i);let o,a;if(e.geometryType==="esriGeometryPoint")o=e.readXForDisplay(),a=e.readYForDisplay();else{const l=e.readCentroidForDisplay();if(!l)return;o=l==null?void 0:l.coords[0],a=l==null?void 0:l.coords[1]}t.recordStart(this.instanceId,this.attributeLayout),t.recordBounds(o,a,n,n);const c=t.vertexCount();this._writeVertex(t,r,o,a),t.indexWrite(c+0),t.indexWrite(c+1),t.indexWrite(c+2),t.indexWrite(c+1),t.indexWrite(c+3),t.indexWrite(c+2),t.recordEnd()}}export{Dr as A,ms as B,S as C,mt as D,vs as E,ir as F,P as G,zr as H,Lr as I,Nr as J,It as K,Yr as L,Or as M,lr as N,nr as O,di as P,vr as Q,Er as R,or as S,tr as T,Se as U,Mr as V,js as W,gr as X,dr as Y,ye as Z,ls as _,Vi as a,oe as b,Xs as c,ar as d,he as e,rr as f,Hs as g,os as h,as as i,Gs as j,Ji as k,ji as l,er as m,Z as n,Ri as o,qi as p,_ as q,Qi as r,Zi as s,zt as t,Ki as u,Xi as v,Wt as w,cr as x,sr as y,Hi as z};
