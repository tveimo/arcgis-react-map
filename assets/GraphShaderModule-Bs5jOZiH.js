import{ci as mt,ar as v,dS as ve,dX as $e,mJ as xe,s as Ie,am as de,kj as _e}from"./index-BU6th8yW.js";import{m as Ne}from"./ProgramTemplate-l9rj7sUi.js";import"./FramebufferObject-DMUPCaZc.js";import{i as Te}from"./ShaderBuilder-B82V1Zuo.js";let sn=class{constructor(){this.drawPhase=mt.MAP|mt.HITTEST|mt.HIGHLIGHT|mt.DEBUG}startup(){}shutdown(t){}};function Me(r){return r.split(" ").map((t,e)=>e>0?t.charAt(0).toUpperCase()+t.slice(1):t).join("")}function Se(r,t){const e=[];for(e.push(t);e.length;){const n=e.pop();if(typeof n=="object"&&!r.has(n.uid)){r.add(n.uid);for(const s of n.children)e.push(s)}}}var F;let Q=(F=class{constructor(){this.uid=F.NodeCount++,this._debugName=null,this._isMutable=!1,this.isImplicit=!1}get isMutable(){return this._isMutable}setMutable(){return this._isMutable=!0,this}setDebugName(t){return t=Me(t),this._debugName=t,this.isImplicit&&this.children[0]instanceof F&&this.children[0].setDebugName(t),this}get debugInfo(){return{name:this._debugName??""}}cloneInto(t){t._debugName=this._debugName,t._isMutable=this._isMutable,t.isImplicit=this.isImplicit,t.uid=this.uid}},F.NodeCount=0,F);function a(r){return typeof r=="object"?r.clone():r}let m=class extends Q{constructor(){super(...arguments),this.shaderType="primitive-node"}},ke=class pe extends Q{constructor(t){super(),this.child=t,this.shaderType="scope-node"}get children(){return[this.child]}clone(){const t=new pe(a(this.child));return this.cloneInto(t),t}};class Jt extends Q{constructor(t,e,n){super(),this.property=t,this.target=e,this.returnType=n,this.shaderType="property-access-node"}get children(){const t=[this.target];return typeof this.property!="string"&&t.push(this.property),t}clone(){const t=new Jt(this.property,a(this.target),this.returnType);return this.cloneInto(t),t}}let Pe=class le extends Q{constructor(t,e,n,s){super(),this.x=t,this.y=e,this.target=n,this.returnType=s,this.shaderType="property-access-2d-node"}get children(){return[this.target,this.x,this.y]}clone(){const t=new le(this.x,this.y,a(this.target),this.returnType);return this.cloneInto(t),t}};class Wt extends Q{constructor(t,e,n){super(),this.condition=t,this.ifTrue=e,this.ifFalse=n,this.shaderType="condition-node"}get children(){return[this.condition,this.ifTrue,this.ifFalse]}clone(){const t=a(this.ifTrue),e=this.ifFalse?a(this.ifFalse):null,n=new Wt(this.condition,t,e);return this.cloneInto(n),n}}let Ce=class fe extends Q{constructor(t,e,n,s){super(),this.captureList=t,this.returnType=e,this.generator=s,this.shaderType="block-node",n&&(this.subgraph=new ke(n))}get children(){return Object.keys(this.captureList).map(t=>this.captureList[t]).concat(this.subgraph??[])}clone(){const t={};for(const n in this.captureList)t[n]=a(this.captureList[n]);const e=new fe(t,this.returnType,this.subgraph?a(this.subgraph.child):this.subgraph,this.generator);return this.cloneInto(e),e}},K=class ye extends Q{constructor(t,e,n,s,i,o=!1){super(),this.token=t,this._children=e,this.isInfix=n,this.isPropertyAccess=s,this.returnType=i,this.isTernary=o,this.shaderType="function-node"}get children(){return this._children}clone(){const t=new ye(this.token,this._children.map(a),this.isInfix,this.isPropertyAccess,this.returnType,this.isTernary);return this.cloneInto(t),t}};var dt,_t,Nt,Tt,Mt,St,kt,Pt,Ct,Ft,Et,Kt,Ut,Vt;function Fe(r){switch(r.type){case"bool":case"bvec2":case"bvec3":case"bvec4":return x;case"float":case"vec2":case"vec3":case"vec4":return p;case"int":case"ivec2":case"ivec3":case"ivec4":return y;case"uint":case"uvec2":case"uvec3":case"uvec4":return bt;default:throw new Error("Unable to handle type")}}function Ee(r){const t=[["float","vec2","vec3","vec4"],["int","ivec2","ivec3","ivec4"],["uint","uvec2","uvec3","uvec4"],["bool","bvec2","bvec3","bvec4"]];for(const e of t)if(e.includes(r))return e.map(n=>Ve[n]);throw new Error("Unable to find type family")}function me(r){return new Proxy(r,{get(t,e){if(e==="constructor")return new Proxy(t.constructor,{construct:(n,s,i)=>me(new n(...s))});if(e in t)return t[e];if(typeof e=="string"){const n=Ee(r.type);return I(r,e,n[e.length-1])}}})}function _(r){return new Proxy(r,{construct:(t,e,n)=>me(new t(...e))})}function Ke(r){return new Proxy(r,{get(t,e){if(e in t)return t[e];if(typeof e=="string"){const n=parseInt(e,10);if(!isNaN(n))return I(r,`[${n}]`,r.elementType.constructor)}}})}function Ue(r){return new Proxy(r,{construct:(t,e,n)=>Ke(new t(...e))})}class jt extends Error{}var U;let At=(U=class extends m{constructor(t,e){super(),this.elementType=t,this.size=e,this.children=[],this.type="array"}clone(){const t=new dt(this.elementType,this.size);return super.cloneInto(t),t}get(t,e){const n=new y(t),s=e!=null?new y(e):null;return s!=null?xt(this,n,s,Fe(this.elementType.constructor)):I(this,n,this.elementType.constructor)}last(){return this.get(this.size-1)}first(){return this.get(0)}findIndex(t,e,n){return Be(this,t,e,n)}glslFindIndex(t,e,n){return Oe(this,t,e,n)}static ofType(t,e){const n={construct:(s,i)=>new dt(new t,e)};return new Proxy(dt,n)}},dt=U,U.type="array",U);At=dt=v([Ue],At);const pt=class pt extends m{constructor(t,e,n,s=!1){super(),this.elementType=t,this.xSize=e,this.ySize=n,this.isRowMajor=s,this.children=[],this.type="array-2d"}clone(){const t=new pt(this.elementType,this.xSize,this.ySize,this.isRowMajor);return super.cloneInto(t),t}get size(){return this.xSize*this.ySize}get(t,e){return this.isRowMajor?this._getRowMajor(t,e):this._getColumnMajor(t,e)}_getColumnMajor(t,e){const n=new y(t);return I(this,new y(e).add(n.multiply(this.xSize)),this.elementType.constructor)}_getRowMajor(t,e){const n=new y(t),s=new y(e);return I(this,n.add(s.multiply(this.ySize)),this.elementType.constructor)}static ofType(t,e,n,s=!1){return new Proxy(At,{construct:(i,o)=>new pt(new t,e,n,s)})}};pt.type="array-2d";let ie=pt;const wt=class wt extends m{constructor(){super(...arguments),this.type="sampler2D",this.children=[]}clone(){const t=new wt;return t.children=this.children.map(a),super.cloneInto(t),t}};wt.type="sampler2D";let oe=wt;var N;let p=(N=class extends m{constructor(t){super(),this.type="float",this.children=[t]}clone(){const t=new N(a(this.children[0]));return super.cloneInto(t),t}multiply(t){return S(this,typeof t=="number"?g(t,N):t)}divide(t){return ft(this,typeof t=="number"?g(t,N):t)}add(t){return st(this,typeof t=="number"?g(t,N):t)}subtract(t){return yt(this,typeof t=="number"?g(t,N):t)}},N.type="float",N);var V;let lt=(V=class extends m{constructor(t,e){super(),this.type="vec2",this.children=[t,e].filter(n=>n!=null)}clone(){const t=new _t(a(this.children[0]),a(this.children[1]));return super.cloneInto(t),t}get 0(){return I(this,"[0]",p)}get 1(){return I(this,"[1]",p)}get 2(){throw new jt}get 3(){throw new jt}multiply(t){return S(this,typeof t=="number"?g(t,p):t)}divide(t){return ft(this,typeof t=="number"?g(t,p):t)}add(t){return st(this,typeof t=="number"?g(t,p):t)}subtract(t){return yt(this,typeof t=="number"?g(t,p):t)}},_t=V,V.type="vec2",V);lt=_t=v([_],lt);var j;let gt=(j=class extends m{constructor(t,e,n){super(),this.type="vec3",this.children=[t,e,n].filter(s=>s!=null)}get 0(){return I(this,"[0]",p)}get 1(){return I(this,"[1]",p)}get 2(){return I(this,"[2]",p)}get 3(){throw new jt}clone(){const t=new Nt(a(this.children[0]),a(this.children[1]),a(this.children[2]));return super.cloneInto(t),t}multiply(t){return S(this,typeof t=="number"?g(t,p):t)}divide(t){return ft(this,typeof t=="number"?g(t,p):t)}add(t){return st(this,typeof t=="number"?g(t,p):t)}subtract(t){return yt(this,typeof t=="number"?g(t,p):t)}},Nt=j,j.type="vec3",j);gt=Nt=v([_],gt);var A;let Y=(A=class extends m{constructor(t,e,n,s){super(),this.type="vec4",this.children=[t,e,n,s].filter(i=>i!=null)}clone(){const t=new Tt(a(this.children[0]),a(this.children[1]),a(this.children[2]),a(this.children[3]));return super.cloneInto(t),t}get 0(){return I(this,"[0]",p)}get 1(){return I(this,"[1]",p)}get 2(){return I(this,"[2]",p)}get 3(){return I(this,"[3]",p)}multiply(t){return S(this,typeof t=="number"?g(t,p):t)}divide(t){return ft(this,typeof t=="number"?g(t,p):t)}add(t){return st(this,typeof t=="number"?g(t,p):t)}subtract(t){return yt(this,typeof t=="number"?g(t,p):t)}},Tt=A,A.type="vec4",A);Y=Tt=v([_],Y);var B;let bt=(B=class extends m{constructor(t){super(),this.type="uint",this.children=[t]}clone(){const t=new Mt(a(this.children[0]));return super.cloneInto(t),t}},Mt=B,B.type="uint",B);bt=Mt=v([_],bt);var O;let Bt=(O=class extends m{constructor(t,e){super(),this.type="uvec2",this.children=[t,e].filter(n=>n!=null)}clone(){const t=new St(a(this.children[0]),a(this.children[1]));return super.cloneInto(t),t}},St=O,O.type="uvec2",O);Bt=St=v([_],Bt);var D;let Ot=(D=class extends m{constructor(t,e,n){super(),this.type="uvec3",this.children=[t,e,n].filter(s=>s!=null)}clone(){const t=new kt(a(this.children[0]),a(this.children[1]),a(this.children[2]));return super.cloneInto(t),t}},kt=D,D.type="uvec3",D);Ot=kt=v([_],Ot);var z;let Dt=(z=class extends m{constructor(t,e,n,s){super(),this.type="uvec4",this.children=[t,e,n,s].filter(i=>i!=null)}clone(){const t=new Pt(a(this.children[0]),a(this.children[1]),a(this.children[2]),a(this.children[3]));return super.cloneInto(t),t}},Pt=z,z.type="uvec4",z);Dt=Pt=v([_],Dt);const vt=class vt extends m{constructor(t){super(),this.type="bool",this.children=[t]}and(t){return He(this,t)}or(t){return ze(this,t)}xor(t){return Ge(this,t)}clone(){const t=new vt(a(this.children[0]));return super.cloneInto(t),t}};vt.type="bool";let x=vt;var L;let zt=(L=class extends m{constructor(t,e){super(),this.type="bvec2",this.children=[t,e].filter(n=>n!=null)}all(){return ee(this)}any(){return ne(this)}clone(){const t=new Ct(a(this.children[0]),a(this.children[1]));return super.cloneInto(t),t}},Ct=L,L.type="bvec2",L);zt=Ct=v([_],zt);var G;let Lt=(G=class extends m{constructor(t,e,n){super(),this.type="bvec3",this.children=[t,e,n].filter(s=>s!=null)}all(){return ee(this)}any(){return ne(this)}clone(){const t=new Ft(a(this.children[0]),a(this.children[1]),a(this.children[2]));return super.cloneInto(t),t}},Ft=G,G.type="bvec3",G);function g(r,t){return typeof r=="number"?new t(r):r}Lt=Ft=v([_],Lt);var R;let Gt=(R=class extends m{constructor(t,e,n,s){super(),this.type="bvec4",this.children=[t,e,n,s].filter(i=>i!=null)}all(){return ee(this)}any(){return ne(this)}clone(){const t=new Et(a(this.children[0]),a(this.children[1]),a(this.children[2]),a(this.children[3]));return super.cloneInto(t),t}},Et=R,R.type="bvec4",R);Gt=Et=v([_],Gt);const C=class C extends m{constructor(t){super(),this.type="int",this.children=[t]}multiply(t){return S(this,g(t,C))}add(t){return st(this,g(t,C))}subtract(t){return yt(this,g(t,C))}divide(t){return ft(this,g(t,C))}clone(){const t=new C(a(this.children[0]));return super.cloneInto(t),t}};C.type="int";let y=C;var H;let Rt=(H=class extends m{constructor(t,e){super(),this.type="ivec2",this.children=[t,e].filter(n=>n!=null)}clone(){const t=new Kt(a(this.children[0]),a(this.children[1]));return super.cloneInto(t),t}},Kt=H,H.type="ivec2",H);Rt=Kt=v([_],Rt);var q;let Ht=(q=class extends m{constructor(t,e,n){super(),this.type="ivec3",this.children=[t,e,n].filter(s=>s!=null)}clone(){const t=new Ut(a(this.children[0]),a(this.children[1]),a(this.children[2]));return super.cloneInto(t),t}},Ut=q,q.type="ivec3",q);Ht=Ut=v([_],Ht);var X;let qt=(X=class extends m{constructor(t,e,n,s){super(),this.type="ivec4",this.children=[t,e,n,s].filter(i=>i!=null)}clone(){const t=new Vt(a(this.children[0]),a(this.children[1]),a(this.children[2]),a(this.children[3]));return super.cloneInto(t),t}},Vt=X,X.type="ivec4",X);qt=Vt=v([_],qt);const $t=class $t extends m{constructor(t,e,n,s){super(),this.type="mat2",this.children=[t,e,n,s]}clone(){const t=new $t(a(this.children[0]),a(this.children[1]),a(this.children[2]),a(this.children[3]));return super.cloneInto(t),t}get(t,e){return xt(this,new y(t),new y(e),p)}multiply(t){return S(this,t)}};$t.type="mat2";let ae=$t;const tt=class tt extends m{static identity(){return new tt(1,0,0,0,1,0,0,0,1)}static fromRotation(t){const e=Ye(t),n=Xe(t);return new tt(n,e,0,Ae(e),n,0,0,0,1)}constructor(t,e,n,s,i,o,h,u,c){super(),this.type="mat3",this.children=[t,e,n,s,i,o,h,u,c]}add(t){return st(this,t)}multiply(t){return S(this,t)}get(t,e){return xt(this,new y(t),new y(e),p)}clone(){const t=new tt(a(this.children[0]),a(this.children[1]),a(this.children[2]),a(this.children[3]),a(this.children[4]),a(this.children[5]),a(this.children[6]),a(this.children[7]),a(this.children[8]));return super.cloneInto(t),t}};tt.type="mat3";let Xt=tt;const et=class et extends m{static identity(){return new et(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}constructor(t,e,n,s,i,o,h,u,c,d,l,b,T,Z,E,k){super(),this.type="mat4",this.children=[t,e,n,s,i,o,h,u,c,d,l,b,T,Z,E,k]}static fromColumns(t,e,n,s){return new et(t.x,t.y,t.z,t.w,e.x,e.y,e.z,e.w,n.x,n.y,n.z,n.w,s.x,s.y,s.z,s.w)}multiply(t){return S(this,t)}get(t,e){return xt(this,new y(t),new y(e),p)}clone(){const t=new et(a(this.children[0]),a(this.children[1]),a(this.children[2]),a(this.children[3]),a(this.children[4]),a(this.children[5]),a(this.children[6]),a(this.children[7]),a(this.children[8]),a(this.children[9]),a(this.children[10]),a(this.children[11]),a(this.children[12]),a(this.children[13]),a(this.children[14]),a(this.children[15]));return super.cloneInto(t),t}};et.type="mat4";let ce=et;const Ve={float:p,vec2:lt,vec3:gt,vec4:Y,int:y,ivec2:Rt,ivec3:Ht,ivec4:qt,uint:bt,uvec2:Bt,uvec3:Ot,uvec4:Dt,bool:x,bvec2:zt,bvec3:Lt,bvec4:Gt},cn=(...r)=>new y(...r),je=(...r)=>new p(...r),un=(...r)=>new lt(...r),hn=(...r)=>new gt(...r),dn=(...r)=>new Y(...r),pn=(...r)=>new Xt(...r);function I(r,t,e){const n=new e(new Jt(t,r,e));return n.isImplicit=!0,n}function xt(r,t,e,n){const s=new n(new Pe(t,e,r,n));return s.isImplicit=!0,s}function w(r,t,e,n=null){if(n){const i=new n,o=new n(new K(r,[t,e],!0,!1,i));return o.isImplicit=!0,o}if(t.type==="float"||t.type==="int"){const i=new e.constructor(new K(r,[t,e],!0,!1,e.constructor));return i.isImplicit=!0,i}if((t.type==="mat2"||t.type==="mat3"||t.type==="mat4")&&e.type!=="float"){const i=new e.constructor(new K(r,[t,e],!0,!1,e.constructor));return i.isImplicit=!0,i}const s=new t.constructor(new K(r,[t,e],!0,!1,t.constructor));return s.isImplicit=!0,s}function f(r,t,e=t.constructor){const n=new e(new K(r,[t],!1,!1,e));return n.isImplicit=!0,n}function M(r,t,e,n=t.constructor){const s=new n(new K(r,[t,e],!1,!1,n));return s.isImplicit=!0,s}function It(r,t,e,n,s=t.constructor){const i=new s(new K(r,[t,e,n],!1,!1,s));return i.isImplicit=!0,i}function Ae(r){return S(r,je(-1))}function te(r,t,e,n){return new t(new Ce(r,t,e,n))}function Be(r,t,e=0,n=r.size){const s=new y(e).setMutable().setDebugName("FindIndexIterator"),i=t(r.get(s)).setDebugName("FindIndexPredicate");return te({iter:s},y,i,({out:h,iter:u,subgraph:c})=>`
${h} = -1;

for (; ${u} < ${n}; ${u}++) {

${c.body}

  if (${c.varName}) {
    ${h} = ${u};
    break;
  }

}
`).setDebugName("FindIndexBlock")}function Oe(r,t,e=0,n=r.size){return te({array:r},y,null,({out:i,array:o})=>`
${i} = -1;
for (int i = ${e}; i < ${n}; i++) {
  bool condition;
  ${t({array:o,i:"i",out:"condition"})}
  if (condition) {
    ${i} = i;
    break;
  }
}
`).setDebugName("GlslFindIndexBlock")}function De(r,t,e){const n=typeof t=="function"?t():t,s=typeof e=="function"?e():e,i=new n.constructor(new Wt(r,n,s));return i.isImplicit=!0,i}function ln(...r){const t=r.map(([h,u])=>typeof u=="function"?[h,u()]:[h,u]),e=t[0][1].constructor,n=t.findIndex(h=>h[0]===!0);if(n===-1)throw new Error("A cond must have a fallthrough case with `true`/; ");const s=t.slice(0,n),i=t[n][1],o=new e(s.reduceRight((h,u)=>De(u[0],u[1],h),i));return o.isImplicit=!0,o}function S(r,t){return w("*",r,t)}function ft(r,t){return w("/",r,t)}function st(r,t){return w("+",r,t)}function yt(r,t){return w("-",r,t)}function fn(r,t){return w("%",r,t)}function yn(r,t){return w("<<",r,t)}function mn(r,t){return w(">>",r,t)}function gn(r,t){return w("&",r,t)}function bn(r,t){return w("|",r,t)}function wn(r,t){return w("^",r,t)}function vn(r){return f("~",r)}function $n(r,t){return w("==",r,t,x)}function xn(r,t){return w("!=",r,t,x)}function In(r,t){return w("<",r,t,x)}function _n(r,t){return w("<=",r,t,x)}function Nn(r,t){return w(">",r,t,x)}function Tn(r,t){return w(">=",r,t,x)}function ze(...r){return r.length<=1?r[0]:r.slice(1).reduce((t,e)=>Le(t,e),r[0])}function Le(r,t){return w("||",r,t,x)}function Ge(...r){return r.length<=1?r[0]:r.slice(1).reduce((t,e)=>Re(t,e),r[0])}function Re(r,t){return w("^^",r,t,x)}function He(...r){return r.length<=1?r[0]:r.slice(1).reduce((t,e)=>qe(t,e),r[0])}function qe(r,t){return w("&&",r,t,x)}function Mn(r){return f("abs",r)}function Sn(r){return f("acos",r)}function kn(r){return f("acosh",r)}function ee(r){return f("all",r,x)}function ne(r){return f("any",r,x)}function Pn(r){return f("asin",r)}function Cn(r){return f("asinh",r)}function Fn(r,t){return t==null?f("atan",r):M("atan",r,t,r.constructor)}function En(r){return f("atanh",r)}function Kn(r){return f("ceil",r)}function Un(r,t,e){return It("clamp",r,t,e,r.constructor)}function Xe(r){return f("cos",r)}function Vn(r){return f("cosh",r)}function jn(r,t){return M("distance",r,t,p)}function An(r,t){return M("dot",r,t,p)}function Bn(r){return f("exp",r)}function On(r){return f("floor",r)}function Dn(r){return f("fract",r)}function zn(r){return f("length",r,p)}function Ln(r){return f("log",r)}function Gn(r){return f("log2",r)}function Rn(r,t){return M("max",r,t)}function Hn(r,t){return M("min",r,t)}function qn(r,t,e){return It("mix",r,t,e)}function Xn(r,t){return M("mod",r,t)}function Yn(r){return f("normalize",r)}function Qn(r){return r.type==="bool"?f("!",r):f("not",r)}function Zn(r,t){return M("pow",r,t)}function Jn(r){return f("round",r)}function Wn(r){return f("sign",r)}function Ye(r){return f("sin",r)}function tr(r){return f("sinh",r)}function er(r,t,e){return It("smoothstep",r,t,e)}function nr(r){return f("sqrt",r)}function rr(r,t){return M("step",r,t,t.constructor)}function sr(r){return f("tan",r)}function ir(r){return f("tanh",r)}function or(r,t,e){return It("texelFetch",r,t,e,Y)}function ar(r,t){return M("texture",r,t,Y)}function cr(r,t){const{initialValue:e,xRange:n,yRange:s,callback:i}=t,[o,h]=n,[u,c]=s,d=new y(0).setMutable().setDebugName("iterX"),l=new y(0).setMutable().setDebugName("iterY"),b=e.setMutable().setDebugName("accumulator"),T=i(b,r.get(d,l),d,l).setDebugName("callback");return te({iterX:d,iterY:l,accumulator:b},e.constructor,T,({out:E,iterX:k,iterY:J,accumulator:ot,subgraph:at})=>`
for (${J} = ${u}; ${J} < ${c}; ${J}++) {
  for (${k} = ${o}; ${k} < ${h}; ${k}++) {

  ${at.body}

  ${ot} = ${at.varName};
  }
}
${E} = ${ot};
`).setDebugName("reduce2DBody")}const ct=5;function $(r,t,e){const n=t.split(`
`);for(const s of n)if(s.trim().length){{let i="";e!=null&&(i+=`/*id:${e??"000"}*/   `),r.body+=i.padEnd(14)}r.body+=" ".repeat(r.indent)+s+`
`}}let ue=class{write(t){for(const e of t.rootOutputNodes())t.shouldPruneOutputNode(e)||(e.variableName=this._write(t,e.node));return t}_createVarName(t,e){let n="";return typeof e!="boolean"&&typeof e!="number"&&e.debugInfo.name&&(n=`${e.debugInfo.name}_`),`${n}v${t.varCount++}`}_write(t,e,n=!1){if(typeof e=="number"||typeof e=="boolean")return e.toString();let s=t.getEmit(e);if(s)return s;switch(e.shaderType){case"scope-node":s=this._writeScopeNode(t,e);break;case"primitive-node":s=this._writePrimitiveNode(t,e,n);break;case"function-node":s=this._writeFunctionNode(t,e);break;case"property-access-node":s=this._writePropertyAccessNode(t,e);break;case"property-access-2d-node":s=this._writePropertyAccess2DNode(t,e);break;case"text-node":s=e.text;break;case"block-node":s=this._writeBlockNode(t,e);break;case"condition-node":s=this._writeConditionNode(t,e)}return t.setEmit(e,s),s}_writeScopeNode(t,e){const n=new e.child.constructor;n.setDebugName(e.debugInfo.name);const s=this._write(t,n,!0);return $(t,`{ /*ScopeStart: ${e.uid} ${e.debugInfo.name}*/`),t.indent+=2,$(t,`${s} = ${this._write(t,e.child)};`),t.indent-=2,$(t,`} /*ScopeEnd: ${e.uid} ${e.debugInfo.name}*/`),s}_writeConditionNode(t,e){const n=new e.ifTrue.constructor,s=this._write(t,n,!0);$(t,`if (${this._write(t,e.condition)}) {`),t.indent+=2;const i=t.createSubgraphContext(),o=this._write(i,e.ifTrue);if(t.body+=i.body,o&&$(t,`${s} = ${o};`),t.indent-=2,$(t,"}"),e.ifFalse){$(t,"else {"),t.indent+=2;const h=t.createSubgraphContext(),u=this._write(h,e.ifFalse);t.body+=h.body,u&&$(t,`${s} = ${u};`),t.indent-=2,$(t,"}")}return s}_writeBlockNode(t,e){const{captureList:n,generator:s,returnType:i}=e,o={};for(const d in n){if(!n[d])continue;const l=this._write(t,n[d]);o[d]=l}const h=new i,u=this._write(t,h,!0);if(o.out=u,e.subgraph){const d=t.createSubgraphContext(),l=this._write(d,e.subgraph.child),b=d.body;o.subgraph={varName:l,body:b}}const c=s(o);return $(t,`{
`),t.indent+=2,$(t,c),t.indent-=2,$(t,`}
`),u}_writePropertyAccessNode(t,e){const n=this._write(t,e.target);return typeof e.property=="string"&&e.property.includes("[")?`${n}${e.property}`:typeof e.property!="string"?`${n}[${this._write(t,e.property)}]`:`${n}.${e.property}`}_writePropertyAccess2DNode(t,e){return`${this._write(t,e.target)}[${this._write(t,e.x)}][${this._write(t,e.y)}]`}_writeFunctionNode(t,e){const n=e.returnType.type;if(e.isInfix){const[o,h]=e.children.map(c=>this._write(t,c)),u=this._createVarName(t,e);return $(t,`${n.padEnd(ct)} ${u} = ${o} ${e.token} ${h};`,e.uid),u}const s=e.children.map(o=>this._write(t,o)).join(", "),i=this._createVarName(t,e);return $(t,`${n.padEnd(ct)} ${i} = ${e.token}(${s});`,e.uid),i}_writePrimitiveNode(t,e,n=!1){var c;const s=t.getInput(e);if(s)return s.isUsed=!0,s.variableName;const i=e.children.length===1&&((c=e.children[0])==null?void 0:c.type)===e.type;if(!e.isMutable&&(e.isImplicit||i))return this._write(t,e.children[0]);const o=this._createVarName(t,e);if(n)return $(t,`${e.type.padEnd(ct)} ${o};`,e.uid),o;const h=!e.debugInfo.name&&!e.isMutable;if(h&&e.type==="float"&&typeof e.children[0]=="number")return Number.isInteger(e.children[0])?e.children[0].toFixed(1):e.children[0].toString();if(h&&e.type==="int"&&typeof e.children[0]=="number"&&Number.isInteger(e.children[0]))return e.children[0].toString();const u=e.children.map(d=>this._write(t,d)).join(", ");return e.type==="array"?($(t,`${e.type.padEnd(ct)} ${o} = [${u}];`,e.uid),o):h?`${e.type}(${u})`:($(t,`${e.type.padEnd(ct)} ${o} = ${e.type}(${u});`,e.uid),o)}};class P{constructor(t,e,n){this.variableName=t,this.variableInputType=e,this.node=n,this.type="shader-input",this.isUsed=!1}clone(){return new P(this.variableName,this.variableInputType,a(this.node))}}let W=class ge{constructor(t,e,n){this.outVariableName=t,this.outVariableType=e,this.node=n,this.type="shader-output"}clone(){const t=new ge(this.outVariableName,this.outVariableType,a(this.node));return t.variableName=this.variableName,t}};class nt{static createVertex(t,e,n,s,i,o){const h=[];for(const c in t){const d=t[c],l=n.get(c);l?h.push(new P(l,"builtin",d)):h.push(new P("a_"+c,"in",d))}for(const c of s){const d=c.uniformHydrated;h.push(new P(c.uniformName,"uniform",d))}const u=[];for(const c in e){const d=e[c];c==="glPosition"?u.push(new W("gl_Position","builtin",d)):c==="glPointSize"?u.push(new W("gl_PointSize","builtin",d)):u.push(new W("v_"+c,"out",d))}return new nt(h,u,i,o)}static createFragment(t,e,n,s,i,o){const h=[],u=Array.from(i.rootOutputNodes());for(const d in t){const l=t[d],b=n.get(d);if(b){h.push(new P(b,"builtin",l));continue}const T=u.find(Z=>Z.node===l);T&&h.push(new P(T.outVariableName,"in",l))}for(const d of s){const l=d.uniformHydrated;h.push(new P(d.uniformName,"uniform",l))}const c=[];for(const d in e){const l=e[d],b=n.get(d);d==="discard"?c.push(new W(null,"discard",l)):b?c.push(new W(b,"builtin",l)):c.push(new W(d,"out",l))}return new nt(h,c,o)}constructor(t,e,n,s){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const i of t)this._inputShaderTypesByNodeUid.set(i.node.uid,i);this._outputShaderTypes=e,this._transformFeedbackBindings=n,this._transformFeedbackNames=new Set(n.map(i=>"v_"+i.propertyKey)),this._usedInFragmentShader=s}shouldPruneOutputNode(t){return!!this._usedInFragmentShader&&t.outVariableType!=="builtin"&&!this._transformFeedbackNames.has(t.outVariableName)&&!this._usedInFragmentShader.has(t.node.uid)}setEmit(t,e){this._nodeEmitMap.set(t.uid,e)}getEmit(t){return this._nodeEmitMap.get(t.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(t){return this._inputShaderTypesByNodeUid.get(t.uid)}*rootOutputNodes(){for(const t of this._outputShaderTypes)yield t}*nodes(){const t=[];for(const e of this._outputShaderTypes.values())t.push(e.node);for(;t.length;){const e=t.pop();typeof e!="number"&&typeof e!="boolean"&&t.push(...e.children.filter(Boolean)),yield e}}*nodesOfTypeOrFunction(){for(const t of this.nodes())typeof t!="number"&&typeof t!="boolean"&&(yield t)}createSubgraphContext(){const t=this.clone();return t.body="",t.indent=this.indent+2,t._nodeEmitMap=new Map(this._nodeEmitMap),t}clone(){const t=new nt([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return t._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,t.indent=this.indent,t.body=this.body,t.varCount=this.varCount,t._nodeEmitMap=this._nodeEmitMap,t}insertVertexShader(t){t.vertex.code.add(""),this._insertInputs(t,"vertex"),t.vertex.code.add(""),t.vertex.code.add("// OUTPUTS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this.rootOutputNodes()){const n=e.outVariableType==="builtin";this.shouldPruneOutputNode(e)||(n?t.vertex.code.add(`// ${e.outVariableType.padEnd(7)} ${e.node.type.padEnd(9)} ${e.outVariableName};`):t.vertex.code.add(`${e.outVariableType.padEnd(10)} ${e.node.type.padEnd(9)} ${e.outVariableName};`))}t.vertex.code.add(""),t.vertex.code.add("void main() {"),t.vertex.code.add("  "+this.body.split(`
`).join(`
  `));for(const e of this.rootOutputNodes())this.shouldPruneOutputNode(e)||t.vertex.code.add(`  ${e.outVariableName} = ${e.variableName};`);t.vertex.code.add("}")}insertFragmentShader(t){this._insertInputs(t,"fragment"),t.fragment.code.add(""),t.fragment.code.add("// OUTPUTS: "),t.fragment.code.add("// --------------------------------------------------------- ");let e=0;for(const n of this.rootOutputNodes())n.outVariableType==="builtin"?t.fragment.code.add(`// ${n.outVariableType.padEnd(7)} ${n.node.type.padEnd(9)} ${n.outVariableName};`):t.outputs.add(n.outVariableName,n.node.type,e++);t.fragment.code.add(""),t.fragment.code.add("void main() {"),t.fragment.code.add("  "+this.body.split(`
`).join(`
  `));for(const n of this.rootOutputNodes())n.outVariableType==="discard"?(t.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),t.fragment.code.add(`  if (${n.variableName}) {`),t.fragment.code.add("    discard;"),t.fragment.code.add("  }"),t.fragment.code.add("  ")):t.fragment.code.add(`  ${n.outVariableName} = ${n.variableName};`);t.fragment.code.add("}")}_insertInputs(t,e){t[e].code.add("// INPUTS: "),t[e].code.add("// --------------------------------------------------------- ");for(const n of this.inputs())n.isUsed&&n.variableInputType!=="builtin"&&(n.node.type==="array"?t[e].code.add(`${n.variableInputType.padEnd(10)} ${n.node.elementType.type.padEnd(9)} ${n.variableName}[${n.node.size}];`):n.node.type==="array-2d"?t[e].code.add(`${n.variableInputType.padEnd(10)} ${n.node.elementType.type.padEnd(9)} ${n.variableName}[${n.node.size}]; // Emulated 2D Array. Not supported by ES3.0`):t[e].code.add(`${n.variableInputType.padEnd(10)} ${n.node.type.padEnd(9)} ${n.variableName};`))}}function Qe(r,t,e){const n=new ve(t.width,t.height);return n.dataType=t.dataType,t.depth&&(n.depth=t.depth),t.flipped&&(n.flipped=t.flipped),t.hasMipmap&&(n.hasMipmap=t.hasMipmap),n.internalFormat=t.internalFormat,t.isImmutable&&(n.isImmutable=t.isImmutable),t.isOpaque&&(n.isOpaque=t.isOpaque),t.maxAnisotropy&&(n.maxAnisotropy=t.maxAnisotropy),n.pixelFormat=t.pixelFormat,t.preMultiplyAlpha&&(n.preMultiplyAlpha=t.preMultiplyAlpha),t.samplingMode&&(n.samplingMode=t.samplingMode),t.target&&(n.target=t.target),n.uniform=t.uniform,t.unpackAlignment&&(n.unpackAlignment=t.unpackAlignment),t.wrapMode&&(n.wrapMode=t.wrapMode),new $e(r,n,e)}const Ze=()=>de.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram");function ut(r,t,e){const n=t.length;if(n!==e){const s=new Ie("Invalid Uniform",`Invalid length, expected ${e} but got ${n}`,{uniformName:r,values:t});Ze().errorOnce(s)}}class he{constructor(t,e,n,s,i,o){this._program=null,this._vao=null,this._temporaryTextures=[],this.vertexShader=t,this.fragmentShader=e,this._locations=n,this._locationInfo=s,this._uniformBindings=i,this._transformFeedbackBindings=o}destroy(){this._program&&this._program.dispose(),this.cleanupTemporaryTextures()}get locations(){return this._locations}get locationInfo(){return this._locationInfo}setUniforms(t){this._uniforms=t}cleanupTemporaryTextures(){for(const t of this._temporaryTextures)t.dispose();this._temporaryTextures=[]}bind(t){const e=this._uniforms;if(!this._program){const s=new Map;for(const[o,h]of this._locations)s.set(o,h);const i=[];for(const o of this._transformFeedbackBindings??[]){const{index:h,propertyKey:u}=o;i[h]=`v_${u}`}this._program=new Ne(t,this.vertexShader,this.fragmentShader,s,new Map,i)}const n=this._program;t.useProgram(n);for(const s of this._uniformBindings){const{shaderModulePath:i,uniformName:o,uniformType:h,uniformArrayLength:u}=s,c=xe(i,e);if(c==null){if(h==="sampler2D")continue;throw new Error(`Failed to find uniform value for ${i}`)}switch(h==="array"||h==="array-2d"?s.uniformArrayElementType:h){case"sampler2D":{const{unit:d,texture:l}=c;if(n.setUniform1i(o,d),"type"in l)t.bindTexture(l,d);else{const b=Qe(t,l.descriptor,l.data);t.bindTexture(b,d)}break}case"int":if(!u){n.setUniform1i(o,c);break}ut(s.uniformName,c,u),n.setUniform1iv(o,c);break;case"float":if(!u){n.setUniform1f(o,c);break}ut(s.uniformName,c,u),n.setUniform1fv(o,c);break;case"vec2":if(!u){n.setUniform2f(o,c[0],c[1]);break}ut(s.uniformName,c,u),n.setUniform2fv(o,c.flat());break;case"vec3":if(!u){n.setUniform3f(o,c[0],c[1],c[2]);break}ut(s.uniformName,c,u),n.setUniform3fv(o,c.flat());break;case"vec4":if(!u){n.setUniform4f(o,c[0],c[1],c[2],c[3]);break}ut(s.uniformName,c,u),n.setUniform4fv(o,c.flat());break;case"mat3":n.setUniformMatrix3fv(o,c);break;case"mat4":n.setUniformMatrix4fv(o,c);break;default:throw new Error(`Unable to set uniform for type ${h}`)}}}}function ht(r){return new r}function it(r,t,e){const n=r.constructor[t]??[];r.constructor.hasOwnProperty(t)||Object.defineProperty(r.constructor,t,{value:n.slice()}),r.constructor[t].push(e)}function hr(r,t){return(e,n)=>{it(e,"locations",{typeCtor:t,propertyKey:n,parameterIndex:null,index:r})}}const Je=r=>(t,e)=>{it(t,"builtins",{builtin:r,propertyKey:e})},dr=r=>(t,e,n)=>{it(t,"inputs",{inputCtor:r,propertyKey:e,parameterIndex:n})},pr=r=>(t,e)=>{it(t,"uniforms",{typeCtor:r,propertyKey:e})},lr=r=>(t,e)=>{it(t,"options",{typeCtor:r,propertyKey:e})},fr=(r,t)=>{it(r,"defines",{propertyKey:t})},Yt=(r,t)=>(e,n)=>{e.constructor.builtins.push({builtin:r,propertyKey:n,typeCtor:t})},re=class re{};re.builtins=[];let Qt=re;v([Yt("gl_VertexID",y)],Qt.prototype,"glVertexID",void 0);class yr{}var rt;let Zt=(rt=class{},rt.builtins=[],rt);v([Yt("gl_FragCoord",Y)],Zt.prototype,"glFragCoord",void 0),v([Yt("gl_PointCoord",lt)],Zt.prototype,"glPointCoord",void 0);class We{}v([Je("gl_FragDepth")],We.prototype,"glFragDepth",void 0);let mr=class{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}},br=class{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const t=this._shaderModuleClass.inputs.findLast(e=>e.propertyKey==="vertex"&&e.parameterIndex===0);if(!t)throw new Error("Unable to find vertex input parameter");return t}get computeInput(){return this._shaderModuleClass.inputs.findLast(t=>t.propertyKey==="vertex"&&t.parameterIndex===1)}get fragmentInput(){const t=this._shaderModuleClass.inputs.findLast(e=>e.propertyKey==="fragment");if(!t)throw new Error("Unable to find fragment input parameter");return t}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){var t;return[...this.vertexInput.inputCtor.locations,...((t=this.computeInput)==null?void 0:t.inputCtor.locations)??[]]}get locationsMap(){const t=new Map,e=new Set;for(const n of this.locations)e.has(n.index)?de.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${n.propertyKey} to ${n.index}. Index already in use`,{locationsMap:t}):(t.set(n.propertyKey,n.index),e.add(n.index));return t}get locationInfo(){if(!this._locationInfo){const t=this.locationsMap,e=Array.from(t.entries()).map(([i,o])=>`${i}.${o}`).join("."),n=_e(e),s=this.computeAttributes;this._locationInfo={hash:n,stringHash:e,locations:t,computeAttributeMap:s}}return this._locationInfo}get renamedLocationsMap(){const t=new Map;for(const e of this.locations)t.set("a_"+e.propertyKey,e.index);return t}get optionPropertyKeys(){if(!this._optionPropertyKeys){const t=new Set;for(const e of this._options)t.add(e.propertyKey);this._optionPropertyKeys=t}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(t,e,n,s){try{const{vertex:i,fragment:o,uniformBindings:h}=this._generateShaders(t,e,n,s);return new he(i,o,this.renamedLocationsMap,this.locationInfo,h,this.transformFeedbackBindings)}catch{return new he("","",this.renamedLocationsMap,this.locationInfo,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(t){const e=this._options.find(s=>s.propertyKey===t);if(e)return{type:"option",className:e.typeCtor};const n=this._uniforms.find(s=>s.propertyKey===t);if(!n)throw new Error(`Unable to find uniform class type for property: ${t}`);return{type:"required",className:n.typeCtor}}getShaderKey(t,e,n,s){const i=Object.keys(t).map(c=>`${c}.${t[c]}`).join("."),o=Object.keys(n).map(c=>`${c}.${n[c]}`).join("."),h=Object.keys(s).map(c=>`${c}.${s[c]}`).join("."),u=Object.keys(e).filter(c=>this.optionPropertyKeys.has(c)&&e[c]).join(".");return`${this.type}.${i}.${o}.${h}.${u}`}_generateShaders(t,e,n,s){const i=[];this._setDefines(n),this._setOptionalUniforms(i,e),this._setRequiredUniforms(i);const o=this._hydrateVertexInput(s),h=this._injectPackPrecisionFactor(o,t),u=this._hydrateComputeInput(),c=u&&this._injectComputePackPrecisionFactor(u,t),d=this.vertex(h,c),l=this._hydrateFragmentInput(d),b=this.fragment(l),T=new Set;for(const be in b){const we=b[be];Se(T,we)}const Z=this._getVertexInputBuiltins(),E=nt.createVertex({...o,...u},d,Z,i,this.transformFeedbackBindings,T);new ue().write(E);const k=this._getFragmentInputBuiltins(b);k.set("glPointCoord","gl_PointCoord");const J=nt.createFragment(l,b,k,i,E,this.transformFeedbackBindings);new ue().write(J);const ot=this._createShaderBuilder(E,J),at=ot.generate("vertex"),se=ot.generate("fragment");return this.logShader&&(console.log(at),console.log(se)),{vertex:at,fragment:se,uniformBindings:i}}_setDefines(t){for(const e in t)this[e]=t[e]}_setOptionalUniforms(t,e){for(const n of this._options)e[n.propertyKey]?this[n.propertyKey]=this._hydrateUniformGroup(t,n):this[n.propertyKey]=null}_setRequiredUniforms(t){for(const e of this._uniforms)this[e.propertyKey]=this._hydrateUniformGroup(t,e)}_hydrateUniformGroup(t,e){const n=new e.typeCtor;for(const s of n._uniforms??[]){const i=ht(s.typeCtor),o=`u_${e.propertyKey}_${s.propertyKey}`,h=i.type,u=[e.propertyKey,s.propertyKey].join(".");if("type"in s.typeCtor&&s.typeCtor.type==="array"){const c=i;t.push({shaderModulePath:u,uniformName:o,uniformType:h,uniformArrayLength:c.size,uniformArrayElementType:c.elementType.type,uniformHydrated:i})}else if("type"in s.typeCtor&&s.typeCtor.type==="array-2d"){const c=i;t.push({shaderModulePath:u,uniformName:o,uniformType:h,uniformArrayLength:c.size,uniformArrayElementType:c.elementType.type,uniformHydrated:i})}else t.push({shaderModulePath:u,uniformName:o,uniformType:h,uniformHydrated:i});n[s.propertyKey]=i}return n}_hydrateVertexInput(t){const e=this.vertexInput.inputCtor,n=e.locations.reduce((s,i)=>t[i.propertyKey]===!1?s:{...s,[i.propertyKey]:ht(i.typeCtor)},{});for(const{propertyKey:s,typeCtor:i}of e.builtins){const o=ht(i);n[s]=o}return n}_hydrateComputeInput(){return this.computeInput==null?null:this.computeInput.inputCtor.locations.reduce((t,e)=>({...t,[e.propertyKey]:ht(e.typeCtor)}),{})}_injectPackPrecisionFactor(t,e){const n={};for(const s in t){const i=t[s],o=e[s];if(o){if(i.type!=="float"&&i.type!=="vec2"&&i.type!=="vec3"&&i.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${i.type}`);n[s]=i.divide(new p(o))}else n[s]=i}return n}_injectComputePackPrecisionFactor(t,e){const n={},s=new Map;for(const i in this.computeAttributes)for(const o of this.computeAttributes[i]??[])s.set(o,i);for(const i in t){const o=t[i],h=s.get(i);if(!h)continue;const u=e[h];if(u){if(o.type!=="float"&&o.type!=="vec2"&&o.type!=="vec3"&&o.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${o.type}`);n[i]=o.divide(new p(u))}else n[i]=o}return n}_hydrateFragmentInput(t){const e={};for(const n in t)e[n]=t[n];for(const{propertyKey:n,typeCtor:s}of Zt.builtins){const i=ht(s);e[n]=i}return e}_getVertexInputBuiltins(){const t=this.vertexInput.inputCtor,e=new Map;for(const{builtin:n,propertyKey:s}of t.builtins)e.set(s,n);return e}_getFragmentInputBuiltins(t){const e=t.constructor,n=new Map;for(const s of e.builtins??[])n.set(s.propertyKey,s.builtin);return n}_createShaderBuilder(t,e){const n=new Te;return this._insertDebugInfo(n),t.insertVertexShader(n),e.insertFragmentShader(n),n}_insertDebugInfo(t){t.vertex.code.add("// DEFINES: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._defines)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`);t.vertex.code.add(""),t.vertex.code.add("// OPTIONS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._options)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`)}};export{lr as $,nr as A,_n as B,Rn as C,In as D,Fn as E,Xe as F,Nn as G,er as H,y as I,Jn as J,fr as K,S as L,or as M,x as N,cn as O,mr as P,Mn as Q,zn as R,fn as S,Dn as T,oe as U,Wn as V,Zn as W,gt as X,Y,Rt as Z,p as _,Xn as a,At as a0,Ae as a1,xn as a2,Tn as a3,Ge as a4,ze as a5,He as a6,wn as a7,vn as a8,mn as a9,he as aA,yn as aa,bn as ab,gn as ac,ir as ad,sr as ae,tr as af,Vn as ag,En as ah,Cn as ai,Pn as aj,kn as ak,Sn as al,Kn as am,Bn as an,Gn as ao,Ln as ap,cr as aq,ie as ar,te as as,yr as at,ce as au,ae as av,jn as aw,Qn as ax,Yn as ay,pn as az,$n as b,lt as c,ar as d,Qt as e,hr as f,pr as g,hn as h,qn as i,br as j,De as k,dn as l,dr as m,Un as n,un as o,Hn as p,rr as q,Xt as r,Ye as s,sn as t,je as u,Zt as v,We as w,ln as x,An as y,On as z};
