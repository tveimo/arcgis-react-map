import{s as L,a6 as V,ep as S,dj as O,ie as N,aR as U,bt as Q,hP as Y,hQ as _,hR as q,dW as B,fg as H}from"./index-rbwFz4i4.js";import{e as M}from"./mat3f64-B5o_lm6j.js";import{g as K,u as W,p as k,h as J}from"./MeshComponent-Bf1YhMug.js";import{c as X}from"./MeshVertexAttributes-CVrzY6IG.js";import{l as R}from"./meshVertexSpaceUtils-DwhFd6bU.js";import{T as j,g as P,M as Z,O as A,o as F,V as ee,y as te,U as re}from"./BufferView-BiQ968Zu.js";import{e as oe,f as ne,s as se,u as E}from"./vec3-G5MlFsge.js";import{n as le,u as ue,c as C}from"./vec4-BbJWY5hk.js";import{e as ae}from"./types-BKo2foNY.js";import{loadGLTF as fe}from"./loader-B3Acwn6c.js";import{u as ie,E as b,o as ce,a as pe,l as me}from"./indexUtils-Cs0M83QL.js";import{B as de}from"./vertexSpaceConversion-AsArFD3k.js";import{n as ye}from"./resourceUtils-Qy__v8Fj.js";import"./meshProperties-BrNWSC8G.js";import"./MeshLocalVertexSpace-DpRCZ-sy.js";import"./mat4f64-q_b6UJoq.js";import"./quat-DzDjyrhk.js";import"./quatf64-aQ5IuZRd.js";import"./Indices-C2d6JGWI.js";import"./spatialReferenceEllipsoidUtils-BdjsAkGw.js";import"./computeTranslationToOriginAndRotation-ClBtgdO8.js";import"./projectPointToVector-BeWRphB-.js";import"./basicInterfaces-CZwQPxTp.js";function ge(e,t,r){const a=e.typedBuffer,n=e.typedBufferStride,o=t.typedBuffer,s=t.typedBufferStride,l=r?r.count:t.count;let u=((r==null?void 0:r.dstIndex)??0)*n,c=((r==null?void 0:r.srcIndex)??0)*s;for(let i=0;i<l;++i){for(let f=0;f<9;++f)a[u+f]=o[c+f];u+=n,c+=s}}Object.freeze(Object.defineProperty({__proto__:null,copy:ge},Symbol.toStringTag,{value:"Module"}));function xe(e,t,r){const a=e.typedBuffer,n=e.typedBufferStride,o=t.typedBuffer,s=t.typedBufferStride,l=r?r.count:t.count;let u=((r==null?void 0:r.dstIndex)??0)*n,c=((r==null?void 0:r.srcIndex)??0)*s;for(let i=0;i<l;++i){for(let f=0;f<16;++f)a[u+f]=o[c+f];u+=n,c+=s}}Object.freeze(Object.defineProperty({__proto__:null,copy:xe},Symbol.toStringTag,{value:"Module"}));function Te(e,t){z(e.typedBuffer,t.typedBuffer,e.typedBufferStride,t.typedBufferStride)}function z(e,t,r=3,a=r){const n=t.length/a;let o=0,s=0;for(let l=0;l<n;++l)e[o]=t[s],e[o+1]=t[s+1],e[o+2]=t[s+2],o+=r,s+=a}function G(e,t,r,a,n){const o=e.typedBuffer,s=e.typedBufferStride,l=(n==null?void 0:n.count)??e.count;let u=((n==null?void 0:n.dstIndex)??0)*s;for(let c=0;c<l;++c)o[u]=t,o[u+1]=r,o[u+2]=a,u+=s}Object.freeze(Object.defineProperty({__proto__:null,copy:z,copyView:Te,fill:G},Symbol.toStringTag,{value:"Module"}));function $e(e,t){D(e.typedBuffer,t,e.typedBufferStride)}function D(e,t,r=4){const a=t.typedBuffer,n=t.typedBufferStride,o=t.count;let s=0,l=0;for(let u=0;u<o;++u)e[s]=a[l],e[s+1]=a[l+1],e[s+2]=a[l+2],e[s+3]=a[l+3],s+=r,l+=n}function $(e,t,r,a,n,o){const s=e.typedBuffer,l=e.typedBufferStride,u=(o==null?void 0:o.count)??e.count;let c=((o==null?void 0:o.dstIndex)??0)*l;for(let i=0;i<u;++i)s[c]=t,s[c+1]=r,s[c+2]=a,s[c+3]=n,c+=l}Object.freeze(Object.defineProperty({__proto__:null,copy:D,copyView:$e,fill:$},Symbol.toStringTag,{value:"Module"}));function x(e,t){return new e(new ArrayBuffer(t*e.ElementCount*ae(e.ElementType)))}async function et(e,t,r){const a=new ie(he(r)),n=(await fe(a,t,r,!0)).model,o=n.lods.shift(),s=new Map,l=new Map;n.textures.forEach((g,h)=>s.set(h,we(g))),n.materials.forEach((g,h)=>l.set(h,ve(g,s)));const u=be(o);for(const g of u.parts)Se(u,g,l);const{position:c,normal:i,tangent:f,color:p,texCoord0:m}=u.vertexAttributes,d=R(e,r),w=e.spatialReference.isGeographic?R(e):d,v=de({vertexAttributes:{position:c.typedBuffer,normal:i==null?void 0:i.typedBuffer,tangent:f==null?void 0:f.typedBuffer},vertexSpace:w,spatialReference:e.spatialReference},d,{allowBufferReuse:!0,sourceUnit:r!=null&&r.unitConversionDisabled?void 0:"meters"});if(!v)throw new L("load-gltf-mesh:vertex-space-projection",`Failed to load mesh from glTF because we could not convert the vertex space from ${w.type} to ${d.type}`);return{transform:null,vertexSpace:d,components:u.components,spatialReference:e.spatialReference,vertexAttributes:new X({...v,color:p==null?void 0:p.typedBuffer,uv:m==null?void 0:m.typedBuffer})}}function he(e){const t=e==null?void 0:e.resolveFile;return t?{busy:!1,request:async(r,a,n)=>{const o=(t==null?void 0:t(r))??r,s=a===b.IMAGE?"image":a===b.BINARY||a===b.IMAGE_AND_TYPE?"array-buffer":"json";return(await V(o,{responseType:s,signal:n==null?void 0:n.signal,timeout:0})).data}}:null}function T(e,t){if(e==null)return"-";const r=e.typedBuffer;return`${O(t,r.buffer,()=>t.size)}/${r.byteOffset}/${r.byteLength}`}function Be(e){return e!=null?e.toString():"-"}function be(e){let t=0;const r={color:!1,tangent:!1,normal:!1,texCoord0:!1},a=new Map,n=new Map,o=[];for(const s of e.parts){const{position:l,normal:u,color:c,tangent:i,texCoord0:f}=s.attributes,p=`
      ${T(l,a)}/
      ${T(u,a)}/
      ${T(c,a)}/
      ${T(i,a)}/
      ${T(f,a)}/
      ${Be(s.transform)}
    `;let m=!1;const d=O(n,p,()=>(m=!0,{start:t,length:l.count}));m&&(t+=l.count),u&&(r.normal=!0),c&&(r.color=!0),i&&(r.tangent=!0),f&&(r.texCoord0=!0),o.push({gltf:s,writeVertices:m,region:d})}return{vertexAttributes:{position:x(re,t),normal:r.normal?x(F,t):null,tangent:r.tangent?x(j,t):null,color:r.color?x(P,t):null,texCoord0:r.texCoord0?x(te,t):null},parts:o,components:[]}}function we(e){return new K({data:(ye(e.data),e.data),wrap:Re(e.parameters.wrap)})}function ve(e,t){const r=new S(Ae(e.color,e.opacity)),a=e.emissiveFactor?new S(Ee(e.emissiveFactor)):null,n=o=>o?new k({scale:o.scale?[o.scale[0],o.scale[1]]:[1,1],rotation:Q(o.rotation??0),offset:o.offset?[o.offset[0],o.offset[1]]:[0,0]}):null;return new W({color:r,colorTexture:t.get(e.colorTexture),normalTexture:t.get(e.normalTexture),emissiveColor:a,emissiveTexture:t.get(e.emissiveTexture),occlusionTexture:t.get(e.occlusionTexture),alphaMode:Me(e.alphaMode),alphaCutoff:e.alphaCutoff,doubleSided:e.doubleSided,metallic:e.metallicFactor,roughness:e.roughnessFactor,metallicRoughnessTexture:t.get(e.metallicRoughnessTexture),colorTextureTransform:n(e.colorTextureTransform),normalTextureTransform:n(e.normalTextureTransform),occlusionTextureTransform:n(e.occlusionTextureTransform),emissiveTextureTransform:n(e.emissiveTextureTransform),metallicRoughnessTextureTransform:n(e.metallicRoughnessTextureTransform)})}function Se(e,t,r){t.writeVertices&&_e(e,t);const{indices:a,attributes:n,primitiveType:o,material:s}=t.gltf;let l=ce(a||n.position.count,o);const u=t.region.start;if(u){const c=new Uint32Array(l);for(let i=0;i<l.length;i++)c[i]+=u;l=c}e.components.push(new J({name:t.gltf.name,faces:l,material:r.get(s),shading:n.normal?"source":"flat",trustSourceNormals:!0}))}function _e(e,t){const{position:r,normal:a,tangent:n,color:o,texCoord0:s}=e.vertexAttributes,l=t.region.start,{attributes:u,transform:c}=t.gltf,i=u.position.count;if(oe(r.slice(l,i),u.position,c),u.normal!=null&&a!=null){const f=Y(M(),c),p=a.slice(l,i);ne(p,u.normal,f),_(f)&&se(p,p)}else a!=null&&G(a,0,0,1,{dstIndex:l,count:i});if(u.tangent!=null&&n!=null){const f=q(M(),c),p=n.slice(l,i);le(p,u.tangent,f),_(f)&&ue(p,p)}else n!=null&&$(n,0,0,1,1,{dstIndex:l,count:i});if(u.texCoord0!=null&&s!=null?pe(s.slice(l,i),u.texCoord0):s!=null&&me(s,0,0,{dstIndex:l,count:i}),u.color!=null&&o!=null){const f=u.color,p=o.slice(l,i);if(f.elementCount===4)f instanceof j?C(p,f,1,255):(f instanceof P||f instanceof Z)&&C(p,f,1/255,255);else{$(p,255,255,255,255);const m=A.fromTypedArray(p.typedBuffer,p.typedBufferStride);f instanceof F?E(m,f,1,255):(f instanceof A||f instanceof ee)&&E(m,f,1/255,255)}}else o!=null&&$(o.slice(l,i),255,255,255,255)}function Me(e){switch(e){case"OPAQUE":return"opaque";case"MASK":return"mask";case"BLEND":return"blend"}}function Re(e){return{horizontal:I(e.s),vertical:I(e.t)}}function I(e){switch(e){case B.CLAMP_TO_EDGE:return"clamp";case B.MIRRORED_REPEAT:return"mirror";case B.REPEAT:return"repeat"}}function y(e){return e**(1/H)*255}function Ae(e,t){return N(y(e[0]),y(e[1]),y(e[2]),t)}function Ee(e){return U(y(e[0]),y(e[1]),y(e[2]))}export{et as loadGLTFMesh};
